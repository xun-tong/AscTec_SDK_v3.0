   1              		.file	"i2c.c"
   9              	.Ltext0:
  10              		.global	I2CMasterState
  11              		.bss
  12              		.align	2
  15              	I2CMasterState:
  16 0000 00000000 		.space	4
  17              		.global	I2CSlaveState
  18              		.align	2
  21              	I2CSlaveState:
  22 0004 00000000 		.space	4
  23              		.global	I2CCount
  24              		.align	2
  27              	I2CCount:
  28 0008 00000000 		.space	4
  29              		.global	RdIndex
  30              		.align	2
  33              	RdIndex:
  34 000c 00000000 		.space	4
  35              		.global	WrIndex
  36              		.align	2
  39              	WrIndex:
  40 0010 00000000 		.space	4
  41              		.text
  42              		.align	2
  43              		.global	I2C0MasterHandler
  45              	I2C0MasterHandler:
  46              	.LFB2:
  47              		.file 1 "i2c.c"
   1:i2c.c         **** /*****************************************************************************
   2:i2c.c         ****  *   i2c.c:  I2C C file for Philips LPC214x Family Microprocessors
   3:i2c.c         ****  *
   4:i2c.c         ****  *   Copyright(C) 2006, Philips Semiconductor
   5:i2c.c         ****  *   All rights reserved.
   6:i2c.c         ****  *
   7:i2c.c         ****  *   History
   8:i2c.c         ****  *   2005.10.01  ver 1.00    Prelimnary version, first Release
   9:i2c.c         ****  *   Modifications from Ascending Technologies GmbH
  10:i2c.c         ****  *
  11:i2c.c         **** *****************************************************************************/
  12:i2c.c         **** #include "LPC214x.h"                        /* LPC21xx definitions */
  13:i2c.c         **** #include "type.h"
  14:i2c.c         **** #include "irq.h"
  15:i2c.c         **** #include "i2c.h"
  16:i2c.c         **** 
  17:i2c.c         **** DWORD I2CMasterState = I2C_IDLE;
  18:i2c.c         **** DWORD I2CSlaveState = I2C_IDLE;
  19:i2c.c         **** 
  20:i2c.c         **** DWORD I2CCmd;
  21:i2c.c         **** DWORD I2CMode;
  22:i2c.c         **** 
  23:i2c.c         **** BYTE I2CMasterBuffer[BUFSIZE];
  24:i2c.c         **** BYTE I2CSlaveBuffer[BUFSIZE];
  25:i2c.c         **** DWORD I2CCount = 0;
  26:i2c.c         **** DWORD I2CReadLength;
  27:i2c.c         **** DWORD I2CWriteLength;
  28:i2c.c         **** 
  29:i2c.c         **** DWORD RdIndex = 0;
  30:i2c.c         **** DWORD WrIndex = 0;
  31:i2c.c         **** 
  32:i2c.c         **** DWORD I2CSTAT;
  33:i2c.c         **** /* 
  34:i2c.c         **** From device to device, the I2C communication protocol may vary, 
  35:i2c.c         **** in the example below, the protocol uses repeated start to read data from or 
  36:i2c.c         **** write to the device:
  37:i2c.c         **** For master read: the sequence is: STA,Addr(W),offset,RE-STA,Addr(w),data...STO 
  38:i2c.c         **** for master write: the sequence is: STA,Addr(W),length,RE-STA,Addr(r),data...STO
  39:i2c.c         **** Thus, in state 8, the address is always WRITE. in state 10, the address could 
  40:i2c.c         **** be READ or WRITE depending on the I2CCmd.
  41:i2c.c         **** */   
  42:i2c.c         **** 
  43:i2c.c         **** /*****************************************************************************
  44:i2c.c         **** ** Function name:		I2C0MasterHandler
  45:i2c.c         **** **
  46:i2c.c         **** ** Descriptions:		I2C0 interrupt handler, deal with master mode
  47:i2c.c         **** **				only.
  48:i2c.c         **** **
  49:i2c.c         **** ** parameters:			None
  50:i2c.c         **** ** Returned value:		None
  51:i2c.c         **** ** 
  52:i2c.c         **** *****************************************************************************/
  53:i2c.c         **** void I2C0MasterHandler (void) __irq 
  54:i2c.c         **** {
  48              	
  49              		@ args = 0, pretend = 0, frame = 4
  50              		@ frame_needed = 1, uses_anonymous_args = 0
  51              		mov	ip, sp
  52 0000 0DC0A0E1 	.LCFI0:
  53              		stmfd	sp!, {fp, ip, lr, pc}
  54 0004 00D82DE9 	.LCFI1:
  55              		sub	fp, ip, #4
  56 0008 04B04CE2 	.LCFI2:
  57              		sub	sp, sp, #4
  58 000c 04D04DE2 	.LCFI3:
  59              		.loc 1 58 0
  55:i2c.c         ****     BYTE StatValue;
  56:i2c.c         **** 
  57:i2c.c         ****     /* this handler deals with master read and master write only */
  58:i2c.c         ****     StatValue = I20STAT;
  60              	536870908
  61 0010 4E32A0E3 		add	r3, r3, #114688
  62 0014 073983E2 		ldr	r3, [r3, #0]
  63 0018 003093E5 		strb	r3, [fp, #-13]
  64 001c 0D304BE5 		.loc 1 61 0
  59:i2c.c         ****     
  60:i2c.c         ****     IENABLE;   
  61:i2c.c         ****     switch ( StatValue )
  65              		r3, [fp, #-13]	@ zero_extendqisi2
  66 0020 0D305BE5 		sub	r3, r3, #8
  67 0024 083043E2 		cmp	r3, #80
  68 0028 500053E3 		ldrls	pc, [pc, r3, asl #2]
  69 002c 03F19F97 		b	.L2
  70 0030 060100EA 		.p2align 2
  71              	.L10:
  72              		.word	.L3
  73 0034 78010000 		.word	.L2
  74 0038 50040000 		.word	.L2
  75 003c 50040000 		.word	.L2
  76 0040 50040000 		.word	.L2
  77 0044 50040000 		.word	.L2
  78 0048 50040000 		.word	.L2
  79 004c 50040000 		.word	.L2
  80 0050 50040000 		.word	.L4
  81 0054 B0010000 		.word	.L2
  82 0058 50040000 		.word	.L2
  83 005c 50040000 		.word	.L2
  84 0060 50040000 		.word	.L2
  85 0064 50040000 		.word	.L2
  86 0068 50040000 		.word	.L2
  87 006c 50040000 		.word	.L2
  88 0070 50040000 		.word	.L5
  89 0074 08020000 		.word	.L2
  90 0078 50040000 		.word	.L2
  91 007c 50040000 		.word	.L2
  92 0080 50040000 		.word	.L2
  93 0084 50040000 		.word	.L2
  94 0088 50040000 		.word	.L2
  95 008c 50040000 		.word	.L2
  96 0090 50040000 		.word	.L6
  97 0094 2C040000 		.word	.L2
  98 0098 50040000 		.word	.L2
  99 009c 50040000 		.word	.L2
 100 00a0 50040000 		.word	.L2
 101 00a4 50040000 		.word	.L2
 102 00a8 50040000 		.word	.L2
 103 00ac 50040000 		.word	.L2
 104 00b0 50040000 		.word	.L7
 105 00b4 70020000 		.word	.L2
 106 00b8 50040000 		.word	.L2
 107 00bc 50040000 		.word	.L2
 108 00c0 50040000 		.word	.L2
 109 00c4 50040000 		.word	.L2
 110 00c8 50040000 		.word	.L2
 111 00cc 50040000 		.word	.L2
 112 00d0 50040000 		.word	.L7
 113 00d4 70020000 		.word	.L2
 114 00d8 50040000 		.word	.L2
 115 00dc 50040000 		.word	.L2
 116 00e0 50040000 		.word	.L2
 117 00e4 50040000 		.word	.L2
 118 00e8 50040000 		.word	.L2
 119 00ec 50040000 		.word	.L2
 120 00f0 50040000 		.word	.L2
 121 00f4 50040000 		.word	.L2
 122 00f8 50040000 		.word	.L2
 123 00fc 50040000 		.word	.L2
 124 0100 50040000 		.word	.L2
 125 0104 50040000 		.word	.L2
 126 0108 50040000 		.word	.L2
 127 010c 50040000 		.word	.L2
 128 0110 50040000 		.word	.L8
 129 0114 74030000 		.word	.L2
 130 0118 50040000 		.word	.L2
 131 011c 50040000 		.word	.L2
 132 0120 50040000 		.word	.L2
 133 0124 50040000 		.word	.L2
 134 0128 50040000 		.word	.L2
 135 012c 50040000 		.word	.L2
 136 0130 50040000 		.word	.L6
 137 0134 2C040000 		.word	.L2
 138 0138 50040000 		.word	.L2
 139 013c 50040000 		.word	.L2
 140 0140 50040000 		.word	.L2
 141 0144 50040000 		.word	.L2
 142 0148 50040000 		.word	.L2
 143 014c 50040000 		.word	.L2
 144 0150 50040000 		.word	.L9
 145 0154 8C030000 		.word	.L2
 146 0158 50040000 		.word	.L2
 147 015c 50040000 		.word	.L2
 148 0160 50040000 		.word	.L2
 149 0164 50040000 		.word	.L2
 150 0168 50040000 		.word	.L2
 151 016c 50040000 		.word	.L2
 152 0170 50040000 		.word	.L9
 153 0174 8C030000 	.L3:
 154              		.loc 1 64 0
  62:i2c.c         ****     {
  63:i2c.c         **** 	case 0x08:			/* A Start condition is issued. */
  64:i2c.c         **** 	I20DAT = I2CMasterBuffer[0];
 155              	si2
 156 0178 8E22A0E3 		str	r3, [r2, #0]
 157 017c 072982E2 		.loc 1 65 0
 158 0180 F8329FE5 		mov	r3, #-536870912
 159 0184 0030D3E5 		add	r3, r3, #114688
 160 0188 003082E5 		add	r3, r3, #24
  65:i2c.c         **** 	I20CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
 161              	2, #40
 162 018c 0E32A0E3 		str	r2, [r3, #0]
 163 0190 073983E2 		.loc 1 66 0
 164 0194 183083E2 		ldr	r2, .L30+4
 165 0198 2820A0E3 		mov	r3, #1
 166 019c 002083E5 		str	r3, [r2, #0]
  66:i2c.c         **** 	I2CMasterState = I2C_STARTED;
 167              	1 67 0
 168 01a0 DC229FE5 		b	.L11
 169 01a4 0130A0E3 	.L4:
 170 01a8 003082E5 		.loc 1 70 0
  67:i2c.c         **** 	break;
 171              		r3, .L30+8
 172 01ac AC0000EA 		ldr	r3, [r3, #0]
 173              		cmp	r3, #1
  68:i2c.c         **** 	
  69:i2c.c         **** 	case 0x10:			/* A repeated started is issued */
  70:i2c.c         **** 	if (  I2CCmd == GET_DEVICE_ID || I2CCmd == GET_TEMPERATURE )
 174              	q	.L12
 175 01b0 D0329FE5 		ldr	r3, .L30+8
 176 01b4 003093E5 		ldr	r3, [r3, #0]
 177 01b8 010053E3 		cmp	r3, #2
 178 01bc 0300000A 		bne	.L14
 179 01c0 C0329FE5 	.L12:
 180 01c4 003093E5 		.loc 1 72 0
 181 01c8 020053E3 		mov	r2, #-536870904
 182 01cc 0400001A 		add	r2, r2, #114688
 183              		ldr	r3, .L30
  71:i2c.c         **** 	{
  72:i2c.c         **** 	    I20DAT = I2CMasterBuffer[2];
 184              	[r3, #2]	@ zero_extendqisi2
 185 01d0 8E22A0E3 		str	r3, [r2, #0]
 186 01d4 072982E2 	.L14:
 187 01d8 A0329FE5 		.loc 1 74 0
 188 01dc 0230D3E5 		mov	r3, #-536870912
 189 01e0 003082E5 		add	r3, r3, #114688
 190              		add	r3, r3, #24
  73:i2c.c         **** 	}
  74:i2c.c         **** 	I20CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC);
 191              	, #40
 192 01e4 0E32A0E3 		str	r2, [r3, #0]
 193 01e8 073983E2 		.loc 1 75 0
 194 01ec 183083E2 		ldr	r2, .L30+4
 195 01f0 2820A0E3 		mov	r3, #2
 196 01f4 002083E5 		str	r3, [r2, #0]
  75:i2c.c         **** 	I2CMasterState = I2C_RESTARTED;
 197              	1 76 0
 198 01f8 84229FE5 		b	.L11
 199 01fc 0230A0E3 	.L5:
 200 0200 003082E5 		.loc 1 79 0
  76:i2c.c         **** 	break;
 201              		r3, .L30+4
 202 0204 960000EA 		ldr	r3, [r3, #0]
 203              		cmp	r3, #1
  77:i2c.c         **** 	
  78:i2c.c         **** 	case 0x18:			/* Regardless, it's a ACK */
  79:i2c.c         **** 	if ( I2CMasterState == I2C_STARTED )
 204              	e	.L15
 205 0208 74329FE5 		.loc 1 81 0
 206 020c 003093E5 		mov	r2, #-536870904
 207 0210 010053E3 		add	r2, r2, #114688
 208 0214 0F00001A 		ldr	r3, .L30+12
  80:i2c.c         **** 	{
  81:i2c.c         **** 	    I20DAT = I2CMasterBuffer[1+WrIndex];
 209              	r3, [r3, #0]
 210 0218 8E22A0E3 		add	r1, r3, #1
 211 021c 072982E2 		ldr	r3, .L30
 212 0220 64329FE5 		ldrb	r3, [r3, r1]	@ zero_extendqisi2
 213 0224 003093E5 		str	r3, [r2, #0]
 214 0228 011083E2 		.loc 1 82 0
 215 022c 4C329FE5 		ldr	r3, .L30+12
 216 0230 0130D3E7 		ldr	r3, [r3, #0]
 217 0234 003082E5 		add	r2, r3, #1
  82:i2c.c         **** 	    WrIndex++;
 218              	.L30+12
 219 0238 4C329FE5 		str	r2, [r3, #0]
 220 023c 003093E5 		.loc 1 83 0
 221 0240 012083E2 		ldr	r2, .L30+4
 222 0244 40329FE5 		mov	r3, #4
 223 0248 002083E5 		str	r3, [r2, #0]
  83:i2c.c         **** 	    I2CMasterState = DATA_ACK;
 224              		.loc 1 85 0
 225 024c 30229FE5 		mov	r3, #-536870912
 226 0250 0430A0E3 		add	r3, r3, #114688
 227 0254 003082E5 		add	r3, r3, #24
 228              		mov	r2, #8
  84:i2c.c         **** 	}
  85:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 229              	r2, [r3, #0]
 230 0258 0E32A0E3 		.loc 1 86 0
 231 025c 073983E2 		b	.L11
 232 0260 183083E2 	.L7:
 233 0264 0820A0E3 		.loc 1 90 0
 234 0268 002083E5 		ldr	r3, .L30+12
  86:i2c.c         **** 	break;
 235              	2, [r3, #0]
 236 026c 7C0000EA 		ldr	r3, .L30+16
 237              		ldr	r3, [r3, #0]
  87:i2c.c         **** 	
  88:i2c.c         **** 	case 0x28:	/* Data byte has been transmitted, regardless ACK or NACK */
  89:i2c.c         **** 	case 0x30:
  90:i2c.c         **** 	if ( WrIndex != I2CWriteLength )
 238              	p	r2, r3
 239 0270 14329FE5 		beq	.L17
 240 0274 002093E5 		.loc 1 92 0
 241 0278 10329FE5 		mov	r2, #-536870904
 242 027c 003093E5 		add	r2, r2, #114688
 243 0280 030052E1 		ldr	r3, .L30+12
 244 0284 2500000A 		ldr	r3, [r3, #0]
  91:i2c.c         **** 	{   
  92:i2c.c         **** 	    I20DAT = I2CMasterBuffer[1+WrIndex]; /* this should be the last one */
 245              	, r3, #1
 246 0288 8E22A0E3 		ldr	r3, .L30
 247 028c 072982E2 		ldrb	r3, [r3, r1]	@ zero_extendqisi2
 248 0290 F4319FE5 		str	r3, [r2, #0]
 249 0294 003093E5 		.loc 1 93 0
 250 0298 011083E2 		ldr	r3, .L30+12
 251 029c DC319FE5 		ldr	r3, [r3, #0]
 252 02a0 0130D3E7 		add	r2, r3, #1
 253 02a4 003082E5 		ldr	r3, .L30+12
  93:i2c.c         **** 	    WrIndex++;
 254              	[r3, #0]
 255 02a8 DC319FE5 		.loc 1 94 0
 256 02ac 003093E5 		ldr	r3, .L30+12
 257 02b0 012083E2 		ldr	r2, [r3, #0]
 258 02b4 D0319FE5 		ldr	r3, .L30+16
 259 02b8 002083E5 		ldr	r3, [r3, #0]
  94:i2c.c         **** 	    if ( WrIndex != I2CWriteLength )
 260              	2, r3
 261 02bc C8319FE5 		beq	.L19
 262 02c0 002093E5 		.loc 1 96 0
 263 02c4 C4319FE5 		ldr	r2, .L30+4
 264 02c8 003093E5 		mov	r3, #4
 265 02cc 030052E1 		str	r3, [r2, #0]
 266 02d0 0300000A 		b	.L23
  95:i2c.c         **** 	    {   
  96:i2c.c         **** 		I2CMasterState = DATA_ACK;
 267              	.loc 1 100 0
 268 02d4 A8219FE5 		ldr	r2, .L30+4
 269 02d8 0430A0E3 		mov	r3, #5
 270 02dc 003082E5 		str	r3, [r2, #0]
 271 02e0 1D0000EA 		.loc 1 101 0
 272              		ldr	r3, .L30+20
  97:i2c.c         **** 	    }
  98:i2c.c         **** 	    else
  99:i2c.c         **** 	    {
 100:i2c.c         **** 		I2CMasterState = DATA_NACK;
 273              	3, [r3, #0]
 274 02e4 98219FE5 		cmp	r3, #0
 275 02e8 0530A0E3 		beq	.L23
 276 02ec 003082E5 		.loc 1 103 0
 101:i2c.c         **** 		if ( I2CReadLength != 0 )
 277              		r3, #-536870912
 278 02f0 9C319FE5 		add	r3, r3, #114688
 279 02f4 003093E5 		mov	r2, #32
 280 02f8 000053E3 		str	r2, [r3, #0]
 281 02fc 1600000A 		.loc 1 104 0
 102:i2c.c         **** 		{
 103:i2c.c         **** 		    I20CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
 282              	r2, .L30+4
 283 0300 0E32A0E3 		mov	r3, #3
 284 0304 073983E2 		str	r3, [r2, #0]
 285 0308 2020A0E3 		b	.L23
 286 030c 002083E5 	.L17:
 104:i2c.c         **** 		    I2CMasterState = I2C_REPEATED_START;
 287              	 1 110 0
 288 0310 6C219FE5 		ldr	r3, .L30+20
 289 0314 0330A0E3 		ldr	r3, [r3, #0]
 290 0318 003082E5 		cmp	r3, #0
 291 031c 0E0000EA 		beq	.L24
 292              		.loc 1 112 0
 105:i2c.c         **** 		}
 106:i2c.c         **** 	    }
 107:i2c.c         **** 	}
 108:i2c.c         **** 	else
 109:i2c.c         **** 	{
 110:i2c.c         **** 	    if ( I2CReadLength != 0 )
 293              	3, #-536870912
 294 0320 6C319FE5 		add	r3, r3, #114688
 295 0324 003093E5 		mov	r2, #32
 296 0328 000053E3 		str	r2, [r3, #0]
 297 032c 0700000A 		.loc 1 113 0
 111:i2c.c         **** 	    {
 112:i2c.c         **** 		I20CONSET = I2CONSET_STA;	/* Set Repeated-start flag */
 298              	r2, .L30+4
 299 0330 0E32A0E3 		mov	r3, #3
 300 0334 073983E2 		str	r3, [r2, #0]
 301 0338 2020A0E3 		b	.L23
 302 033c 002083E5 	.L24:
 113:i2c.c         **** 		I2CMasterState = I2C_REPEATED_START;
 303              	 1 117 0
 304 0340 3C219FE5 		ldr	r2, .L30+4
 305 0344 0330A0E3 		mov	r3, #5
 306 0348 003082E5 		str	r3, [r2, #0]
 307 034c 020000EA 	.L23:
 308              		.loc 1 120 0
 114:i2c.c         **** 	    }
 115:i2c.c         **** 	    else
 116:i2c.c         **** 	    {
 117:i2c.c         **** 		I2CMasterState = DATA_NACK;
 309              	3, #-536870912
 310 0350 2C219FE5 		add	r3, r3, #114688
 311 0354 0530A0E3 		add	r3, r3, #24
 312 0358 003082E5 		mov	r2, #8
 313              		str	r2, [r3, #0]
 118:i2c.c         **** 	    }
 119:i2c.c         **** 	}
 120:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 314              	 1 121 0
 315 035c 0E32A0E3 		b	.L11
 316 0360 073983E2 	.L8:
 317 0364 183083E2 		.loc 1 124 0
 318 0368 0820A0E3 		mov	r3, #-536870912
 319 036c 002083E5 		add	r3, r3, #114688
 121:i2c.c         **** 	break;
 320              	3, r3, #24
 321 0370 3B0000EA 		mov	r2, #8
 322              		str	r2, [r3, #0]
 122:i2c.c         **** 	
 123:i2c.c         **** 	case 0x40:	/* Master Receive, SLA_R has been sent */
 124:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 323              	oc 1 125 0
 324 0374 0E32A0E3 		b	.L11
 325 0378 073983E2 	.L9:
 326 037c 183083E2 		.loc 1 129 0
 327 0380 0820A0E3 		ldr	r3, .L30+24
 328 0384 002083E5 		ldr	r3, [r3, #0]
 125:i2c.c         **** 	break;
 329              	1, r3, #3
 330 0388 350000EA 		mov	r3, #-536870904
 331              		add	r3, r3, #114688
 126:i2c.c         **** 	
 127:i2c.c         **** 	case 0x50:	/* Data byte has been received, regardless following ACK or NACK */
 128:i2c.c         **** 	case 0x58:
 129:i2c.c         **** 	I2CMasterBuffer[3+RdIndex] = I20DAT;
 332              	r	r3, [r3, #0]
 333 038c 04319FE5 		and	r3, r3, #255
 334 0390 003093E5 		ldr	r2, .L30
 335 0394 031083E2 		strb	r3, [r2, r1]
 336 0398 8E32A0E3 		.loc 1 130 0
 337 039c 073983E2 		ldr	r3, .L30+24
 338 03a0 003093E5 		ldr	r3, [r3, #0]
 339 03a4 FF3003E2 		add	r2, r3, #1
 340 03a8 D0209FE5 		ldr	r3, .L30+24
 341 03ac 0130C2E7 		str	r2, [r3, #0]
 130:i2c.c         **** 	RdIndex++;
 342              	1 0
 343 03b0 E0309FE5 		ldr	r3, .L30+24
 344 03b4 003093E5 		ldr	r2, [r3, #0]
 345 03b8 012083E2 		ldr	r3, .L30+20
 346 03bc D4309FE5 		ldr	r3, [r3, #0]
 347 03c0 002083E5 		cmp	r2, r3
 131:i2c.c         **** 	if ( RdIndex != I2CReadLength )
 348              	L26
 349 03c4 CC309FE5 		.loc 1 133 0
 350 03c8 002093E5 		ldr	r2, .L30+4
 351 03cc C0309FE5 		mov	r3, #4
 352 03d0 003093E5 		str	r3, [r2, #0]
 353 03d4 030052E1 		b	.L28
 354 03d8 0300000A 	.L26:
 132:i2c.c         **** 	{   
 133:i2c.c         **** 	    I2CMasterState = DATA_ACK;
 355              	 137 0
 356 03dc A0209FE5 		ldr	r2, .L30+24
 357 03e0 0430A0E3 		mov	r3, #0
 358 03e4 003082E5 		str	r3, [r2, #0]
 359 03e8 050000EA 		.loc 1 138 0
 360              		ldr	r2, .L30+4
 134:i2c.c         **** 	}
 135:i2c.c         **** 	else
 136:i2c.c         **** 	{
 137:i2c.c         **** 	    RdIndex = 0;
 361              	3, #5
 362 03ec A4209FE5 		str	r3, [r2, #0]
 363 03f0 0030A0E3 	.L28:
 364 03f4 003082E5 		.loc 1 140 0
 138:i2c.c         **** 	    I2CMasterState = DATA_NACK;
 365              		r3, #-536870912
 366 03f8 84209FE5 		add	r3, r3, #114688
 367 03fc 0530A0E3 		mov	r2, #4
 368 0400 003082E5 		str	r2, [r3, #0]
 369              		.loc 1 141 0
 139:i2c.c         **** 	}
 140:i2c.c         **** 	I20CONSET = I2CONSET_AA;	/* assert ACK after data is received */
 370              	r3, #-536870912
 371 0404 0E32A0E3 		add	r3, r3, #114688
 372 0408 073983E2 		add	r3, r3, #24
 373 040c 0420A0E3 		mov	r2, #8
 374 0410 002083E5 		str	r2, [r3, #0]
 141:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 375              	 1 142 0
 376 0414 0E32A0E3 		b	.L11
 377 0418 073983E2 	.L6:
 378 041c 183083E2 		.loc 1 146 0
 379 0420 0820A0E3 		mov	r3, #-536870912
 380 0424 002083E5 		add	r3, r3, #114688
 142:i2c.c         **** 	break;
 381              	3, r3, #24
 382 0428 0D0000EA 		mov	r2, #8
 383              		str	r2, [r3, #0]
 143:i2c.c         **** 	
 144:i2c.c         **** 	case 0x20:			/* regardless, it's a NACK */
 145:i2c.c         **** 	case 0x48:
 146:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 384              	oc 1 147 0
 385 042c 0E32A0E3 		ldr	r2, .L30+4
 386 0430 073983E2 		mov	r3, #5
 387 0434 183083E2 		str	r3, [r2, #0]
 388 0438 0820A0E3 		.loc 1 148 0
 389 043c 002083E5 		b	.L11
 147:i2c.c         **** 	I2CMasterState = DATA_NACK;
 390              	.loc 1 153 0
 391 0440 3C209FE5 		mov	r3, #-536870912
 392 0444 0530A0E3 		add	r3, r3, #114688
 393 0448 003082E5 		add	r3, r3, #24
 148:i2c.c         **** 	break;
 394              		r2, #8
 395 044c 040000EA 		str	r2, [r3, #0]
 396              	.L11:
 149:i2c.c         **** 	
 150:i2c.c         **** 	case 0x38:			/* Arbitration lost, in this example, we don't
 151:i2c.c         **** 					deal with multiple master situation */
 152:i2c.c         **** 	default:
 153:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;	
 397              	oc 1 158 0
 398 0450 0E32A0E3 		mov	r3, #0
 399 0454 073983E2 		sub	r3, r3, #4048
 400 0458 183083E2 		mov	r2, #0
 401 045c 0820A0E3 		str	r2, [r3, #0]
 402 0460 002083E5 		.loc 1 160 0
 403              		sub	sp, fp, #12
 154:i2c.c         **** 	break;
 155:i2c.c         ****     }
 156:i2c.c         ****     
 157:i2c.c         ****     IDISABLE;
 158:i2c.c         ****     VICVectAddr = 0;		/* Acknowledge Interrupt */
 404              	sp, {fp, sp, lr}
 405 0464 0030A0E3 		bx	lr
 406 0468 FD3E43E2 	.L31:
 407 046c 0020A0E3 		.align	2
 408 0470 002083E5 	.L30:
 159:i2c.c         **** 
 160:i2c.c         **** }
 409              	d	I2CMasterBuffer
 410 0474 0CD04BE2 		.word	I2CMasterState
 411 0478 00689DE8 		.word	I2CCmd
 412 047c 1EFF2FE1 		.word	WrIndex
 413              		.word	I2CWriteLength
 414              		.word	I2CReadLength
 415              		.word	RdIndex
 416 0480 00000000 	.LFE2:
 418 0488 00000000 		.align	2
 419 048c 00000000 		.global	I2C0_send_motordata
 421 0494 00000000 	I2C0_send_motordata:
 422 0498 00000000 	.LFB3:
 423              		.loc 1 164 0
 424              		@ Function supports interworking.
 425              		@ args = 0, pretend = 0, frame = 0
 426              		@ frame_needed = 1, uses_anonymous_args = 0
 427              		mov	ip, sp
 428              	.LCFI4:
 429              		stmfd	sp!, {fp, ip, lr, pc}
 161:i2c.c         **** 
 162:i2c.c         **** 
 163:i2c.c         **** void I2C0_send_motordata(void)
 164:i2c.c         **** {
 430              	#4
 431              	.LCFI6:
 432              		.loc 1 165 0
 433              		ldr	r2, .L34
 434 049c 0DC0A0E1 		mov	r3, #0
 435              		str	r3, [r2, #0]
 436 04a0 00D82DE9 		.loc 1 166 0
 437              		ldr	r2, .L34+4
 438 04a4 04B04CE2 		mov	r3, #0
 439              		str	r3, [r2, #0]
 165:i2c.c         **** 	WrIndex=0;
 440              	7 0
 441 04a8 80209FE5 		ldr	r2, .L34+8
 442 04ac 0030A0E3 		mov	r3, #5
 443 04b0 003082E5 		str	r3, [r2, #0]
 166:i2c.c         **** 	RdIndex=0;
 444              	c 1 168 0
 445 04b4 78209FE5 		ldr	r2, .L34+12
 446 04b8 0030A0E3 		mov	r3, #0
 447 04bc 003082E5 		str	r3, [r2, #0]
 167:i2c.c         **** 	I2CWriteLength = 5;
 448              	c 1 169 0
 449 04c0 70209FE5 		ldr	r2, .L34+16
 450 04c4 0530A0E3 		mov	r3, #2
 451 04c8 003082E5 		strb	r3, [r2, #0]
 168:i2c.c         **** 	I2CReadLength = 0;
 452              	c 1 170 0
 453 04cc 68209FE5 		ldr	r2, .L34+16
 454 04d0 0030A0E3 		mov	r3, #100
 455 04d4 003082E5 		strb	r3, [r2, #1]
 169:i2c.c         ****     I2CMasterBuffer[0] = 0x02;
 456              	c 1 171 0
 457 04d8 60209FE5 		ldr	r2, .L34+16
 458 04dc 0230A0E3 		mov	r3, #100
 459 04e0 0030C2E5 		strb	r3, [r2, #2]
 170:i2c.c         ****     I2CMasterBuffer[1] = 100;
 460              	c 1 172 0
 461 04e4 54209FE5 		ldr	r2, .L34+16
 462 04e8 6430A0E3 		mov	r3, #100
 463 04ec 0130C2E5 		strb	r3, [r2, #3]
 171:i2c.c         ****     I2CMasterBuffer[2] = 100;
 464              	c 1 173 0
 465 04f0 48209FE5 		ldr	r2, .L34+16
 466 04f4 6430A0E3 		mov	r3, #1
 467 04f8 0230C2E5 		strb	r3, [r2, #4]
 172:i2c.c         ****     I2CMasterBuffer[3] = 100;
 468              	c 1 177 0
 469 04fc 3C209FE5 		ldr	r2, .L34+20
 470 0500 6430A0E3 		mov	r3, #2
 471 0504 0330C2E5 		str	r3, [r2, #0]
 173:i2c.c         ****     I2CMasterBuffer[4] = 1;
 472              	c 1 178 0
 473 0508 30209FE5 		bl	I2CEngine
 474 050c 0130A0E3 		.loc 1 179 0
 475 0510 0430C2E5 		sub	sp, fp, #12
 174:i2c.c         **** 
 175:i2c.c         ****     //I20CONSET = I2CONSET_STA;	/* Set Start flag */
 176:i2c.c         ****     //if ( !I2CStart() ) I2CStop();
 177:i2c.c         ****     I2CCmd = GET_TEMPERATURE;
 476              	fd	sp, {fp, sp, lr}
 477 0514 28209FE5 		bx	lr
 478 0518 0230A0E3 	.L35:
 479 051c 003082E5 		.align	2
 178:i2c.c         **** 	I2CEngine();
 480              	:
 481 0520 FEFFFFEB 		.word	WrIndex
 179:i2c.c         **** }
 482              	word	RdIndex
 483 0524 0CD04BE2 		.word	I2CWriteLength
 484 0528 00689DE8 		.word	I2CReadLength
 485 052c 1EFF2FE1 		.word	I2CMasterBuffer
 486              		.word	I2CCmd
 487              	.LFE3:
 489 0530 00000000 		.align	2
 490 0534 00000000 		.global	I2CStart
 492 053c 00000000 	I2CStart:
 493 0540 00000000 	.LFB4:
 494 0544 00000000 		.loc 1 193 0
 495              		@ Function supports interworking.
 496              		@ args = 0, pretend = 0, frame = 8
 497              		@ frame_needed = 1, uses_anonymous_args = 0
 498              		mov	ip, sp
 499              	.LCFI7:
 500              		stmfd	sp!, {fp, ip, lr, pc}
 501              	.LCFI8:
 180:i2c.c         **** 
 181:i2c.c         **** /*****************************************************************************
 182:i2c.c         **** ** Function name:		I2CStart
 183:i2c.c         **** **
 184:i2c.c         **** ** Descriptions:		Create I2C start condition, a timeout
 185:i2c.c         **** **				value is set if the I2C never gets started,
 186:i2c.c         **** **				and timed out. It's a fatal error. 
 187:i2c.c         **** **
 188:i2c.c         **** ** parameters:			None
 189:i2c.c         **** ** Returned value:		true or false, return false if timed out
 190:i2c.c         **** ** 
 191:i2c.c         **** *****************************************************************************/
 192:i2c.c         **** unsigned int I2CStart( void )
 193:i2c.c         **** {
 502              	I9:
 503              		sub	sp, sp, #8
 504              	.LCFI10:
 505              		.loc 1 195 0
 506 0548 0DC0A0E1 		mov	r3, #-536870912
 507              		add	r3, r3, #114688
 508 054c 00D82DE9 		mov	r2, #32
 509              		str	r2, [r3, #0]
 510 0550 04B04CE2 		.loc 1 199 0
 511              		mov	r3, #0
 512 0554 08D04DE2 		str	r3, [fp, #-20]
 513              		.loc 1 200 0
 194:i2c.c         ****     /*--- Issue a start condition ---*/
 195:i2c.c         ****     I20CONSET = I2CONSET_STA;	/* Set Start flag */
 514              		str	r3, [fp, #-16]
 515 0558 0E32A0E3 	.L37:
 516 055c 073983E2 		.loc 1 203 0
 517 0560 2020A0E3 		ldr	r3, .L44
 518 0564 002083E5 		ldr	r3, [r3, #0]
 196:i2c.c         ****     
 197:i2c.c         ****     /*--- Wait until START transmitted ---*/
 198:i2c.c         **** 
 199:i2c.c         ****     unsigned int timeout = 0;
 519              	r3, #1
 520 0568 0030A0E3 		bne	.L38
 521 056c 14300BE5 		.loc 1 205 0
 200:i2c.c         ****     unsigned int returnValue = FALSE;
 522              	v	r3, #1
 523 0570 0030A0E3 		str	r3, [fp, #-16]
 524 0574 10300BE5 		.loc 1 206 0
 525              		b	.L40
 201:i2c.c         ****     while( 1 )
 202:i2c.c         ****     {
 203:i2c.c         **** 	if ( I2CMasterState == I2C_STARTED )
 526              	:
 527 0578 58309FE5 		.loc 1 208 0
 528 057c 003093E5 		ldr	r2, [fp, #-20]
 529 0580 010053E3 		mov	r3, #16777216
 530 0584 0200001A 		sub	r3, r3, #2
 204:i2c.c         **** 	{
 205:i2c.c         **** 	    returnValue = TRUE;
 531              	r2, r3
 532 0588 0130A0E3 		bls	.L41
 533 058c 10300BE5 		.loc 1 210 0
 206:i2c.c         **** 	    break;	
 534              	v	r3, #0
 535 0590 0B0000EA 		str	r3, [fp, #-16]
 536              		.loc 1 211 0
 207:i2c.c         **** 	}
 208:i2c.c         **** 	if ( timeout >= MAX_TIMEOUT )
 537              	.L40
 538 0594 14201BE5 	.L41:
 539 0598 0134A0E3 		.loc 1 213 0
 540 059c 023043E2 		ldr	r3, [fp, #-20]
 541 05a0 030052E1 		add	r3, r3, #1
 542 05a4 0200009A 		str	r3, [fp, #-20]
 209:i2c.c         **** 	{
 210:i2c.c         **** 	    returnValue = FALSE;
 543              	1 214 0
 544 05a8 0030A0E3 		b	.L37
 545 05ac 10300BE5 	.L40:
 211:i2c.c         **** 	    break;
 546              	oc 1 215 0
 547 05b0 030000EA 		ldr	r3, [fp, #-16]
 548              		.loc 1 216 0
 212:i2c.c         **** 	}
 213:i2c.c         **** 	timeout++;
 549              	v	r0, r3
 550 05b4 14301BE5 		sub	sp, fp, #12
 551 05b8 013083E2 		ldmfd	sp, {fp, sp, lr}
 552 05bc 14300BE5 		bx	lr
 214:i2c.c         ****     }
 553              	:
 554 05c0 ECFFFFEA 		.align	2
 555              	.L44:
 215:i2c.c         ****     return( returnValue );
 556              	ord	I2CMasterState
 557 05c4 10301BE5 	.LFE4:
 216:i2c.c         **** }
 558              	size	I2CStart, .-I2CStart
 559 05c8 0300A0E1 		.align	2
 560 05cc 0CD04BE2 		.global	I2CStop
 562 05d4 1EFF2FE1 	I2CStop:
 563              	.LFB5:
 564              		.loc 1 229 0
 565              		@ Function supports interworking.
 566 05d8 00000000 		@ args = 0, pretend = 0, frame = 0
 567              		@ frame_needed = 1, uses_anonymous_args = 0
 568              		mov	ip, sp
 569              	.LCFI11:
 570              		stmfd	sp!, {fp, ip, lr, pc}
 571              	.LCFI12:
 572              		sub	fp, ip, #4
 573              	.LCFI13:
 217:i2c.c         **** 
 218:i2c.c         **** /*****************************************************************************
 219:i2c.c         **** ** Function name:		I2CStop
 220:i2c.c         **** **
 221:i2c.c         **** ** Descriptions:		Set the I2C stop condition, if the routine
 222:i2c.c         **** **				never exit, it's a fatal bus error.
 223:i2c.c         **** **
 224:i2c.c         **** ** parameters:			None
 225:i2c.c         **** ** Returned value:		true or never return
 226:i2c.c         **** ** 
 227:i2c.c         **** *****************************************************************************/
 228:i2c.c         **** unsigned int I2CStop( void )
 229:i2c.c         **** {
 574              	ov	r3, #-536870912
 575              		add	r3, r3, #114688
 576              		mov	r2, #16
 577              		str	r2, [r3, #0]
 578 05dc 0DC0A0E1 		.loc 1 231 0
 579              		mov	r3, #-536870912
 580 05e0 00D82DE9 		add	r3, r3, #114688
 581              		add	r3, r3, #24
 582 05e4 04B04CE2 		mov	r2, #8
 583              		str	r2, [r3, #0]
 230:i2c.c         ****     I20CONSET = I2CONSET_STO;      /* Set Stop flag */ 
 584              	c 1 234 0
 585 05e8 0E32A0E3 		mov	r3, #-536870912
 586 05ec 073983E2 		add	r3, r3, #114688
 587 05f0 1020A0E3 		ldr	r3, [r3, #0]
 588 05f4 002083E5 		and	r3, r3, #16
 231:i2c.c         ****     I20CONCLR = I2CONCLR_SIC;  /* Clear SI flag */ 
 589              	r3, #0
 590 05f8 0E32A0E3 		bne	.L47
 591 05fc 073983E2 		.loc 1 235 0
 592 0600 183083E2 		mov	r3, #1
 593 0604 0820A0E3 		.loc 1 236 0
 594 0608 002083E5 		mov	r0, r3
 595              		sub	sp, fp, #12
 232:i2c.c         ****             
 233:i2c.c         ****     /*--- Wait for STOP detected ---*/
 234:i2c.c         ****     while( I20CONSET & I2CONSET_STO );
 596              	sp, {fp, sp, lr}
 597 060c 0E32A0E3 		bx	lr
 598 0610 073983E2 	.LFE5:
 600 0618 103003E2 		.align	2
 601 061c 000053E3 		.global	I2CInit
 235:i2c.c         ****     return TRUE;
 603              	:
 604 0624 0130A0E3 	.LFB6:
 236:i2c.c         **** }
 605              	loc 1 249 0
 606 0628 0300A0E1 		@ Function supports interworking.
 607 062c 0CD04BE2 		@ args = 0, pretend = 0, frame = 4
 608 0630 00689DE8 		@ frame_needed = 1, uses_anonymous_args = 0
 609 0634 1EFF2FE1 		mov	ip, sp
 610              	.LCFI14:
 611              		stmfd	sp!, {fp, ip, lr, pc}
 612              	.LCFI15:
 613              		sub	fp, ip, #4
 614              	.LCFI16:
 615              		sub	sp, sp, #4
 616              	.LCFI17:
 237:i2c.c         **** 
 238:i2c.c         **** /*****************************************************************************
 239:i2c.c         **** ** Function name:		I2CInit
 240:i2c.c         **** **
 241:i2c.c         **** ** Descriptions:		Initialize I2C controller
 242:i2c.c         **** **
 243:i2c.c         **** ** parameters:			I2c mode is either MASTER or SLAVE
 244:i2c.c         **** ** Returned value:		true or false, return false if the I2C
 245:i2c.c         **** **				interrupt handler was not installed correctly
 246:i2c.c         **** ** 
 247:i2c.c         **** *****************************************************************************/
 248:i2c.c         **** void I2CInit( unsigned int I2cMode ) 
 249:i2c.c         **** {
 617              	, #-16]
 618              		.loc 1 250 0
 619              		mov	r2, #-536870904
 620              		add	r2, r2, #163840
 621 0638 0DC0A0E1 		mov	r3, #-536870904
 622              		add	r3, r3, #163840
 623 063c 00D82DE9 		ldr	r3, [r3, #0]
 624              		orr	r3, r3, #12
 625 0640 04B04CE2 		str	r3, [r2, #0]
 626              		.loc 1 251 0
 627 0644 04D04DE2 		mov	r3, #-536870908
 628              		add	r3, r3, #163840
 629 0648 10000BE5 		mov	r2, #12
 250:i2c.c         ****     IODIR0|= 0x0C;	/* set port 0.2 and port 0.3 to output, high */
 630              	 #0]
 631 064c 8E22A0E3 		.loc 1 256 0
 632 0650 0A2982E2 		mov	r3, #-536870912
 633 0654 8E32A0E3 		add	r3, r3, #114688
 634 0658 0A3983E2 		add	r3, r3, #24
 635 065c 003093E5 		mov	r2, #108
 636 0660 0C3083E3 		str	r2, [r3, #0]
 637 0664 003082E5 		.loc 1 257 0
 251:i2c.c         ****     IOSET0 = 0x0C;
 638              	 #-536870912
 639 0668 4E32A0E3 		add	r2, r2, #114688
 640 066c 0A3983E2 		mov	r3, #-536870912
 641 0670 0C20A0E3 		add	r3, r3, #114688
 642 0674 002083E5 		ldr	r3, [r3, #0]
 252:i2c.c         **** 
 253:i2c.c         **** //    PINSEL0 |= (0<<7)|(1<<6)|(0<<5)|(1<<4); //Select SCL0 and SDA0
 254:i2c.c         **** 
 255:i2c.c         ****     /*--- Clear flags ---*/
 256:i2c.c         ****     I20CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC;
 643              	r3, r3, #16
 644 0678 0E32A0E3 		str	r3, [r2, #0]
 645 067c 073983E2 		.loc 1 260 0
 646 0680 183083E2 		mov	r3, #-536870912
 647 0684 6C20A0E3 		add	r3, r3, #114688
 648 0688 002083E5 		add	r3, r3, #20
 257:i2c.c         ****     I20CONSET &= (~I2CONSET_STO);
 649              	2, #128
 650 068c 0E22A0E3 		str	r2, [r3, #0]
 651 0690 072982E2 		.loc 1 261 0
 652 0694 0E32A0E3 		mov	r3, #-536870912
 653 0698 073983E2 		add	r3, r3, #114688
 654 069c 003093E5 		add	r3, r3, #16
 655 06a0 1030C3E3 		mov	r2, #128
 656 06a4 003082E5 		str	r2, [r3, #0]
 258:i2c.c         **** 
 259:i2c.c         ****     /*--- Reset registers ---*/
 260:i2c.c         ****     I20SCLL   = I2SCLL_SCLL;
 657              	269 0
 658 06a8 0E32A0E3 		mov	r3, #-536870912
 659 06ac 073983E2 		add	r3, r3, #114688
 660 06b0 143083E2 		mov	r2, #64
 661 06b4 8020A0E3 		str	r2, [r3, #0]
 662 06b8 002083E5 		.loc 1 270 0
 261:i2c.c         ****     I20SCLH   = I2SCLH_SCLH;
 663              	p, fp, #12
 664 06bc 0E32A0E3 		ldmfd	sp, {fp, sp, lr}
 665 06c0 073983E2 		bx	lr
 666 06c4 103083E2 	.LFE6:
 668 06cc 002083E5 		.align	2
 262:i2c.c         **** 
 263:i2c.c         **** // by Xun
 264:i2c.c         ****     /* set I2C rate to 400kHz, given PCLK = 15MHz. datasheet P.220 */
 265:i2c.c         **** //    I20SCLL = 19;
 266:i2c.c         ****  //   I20SCLH = 18;
 267:i2c.c         **** 
 268:i2c.c         **** //    unsigned long flag_irq = install_irq(I2C0_INT, (void *) I2C0MasterHandler );
 269:i2c.c         ****     I20CONSET = I2CONSET_I2EN;
 669              	al	I2CEngine
 671 06d4 073983E2 	I2CEngine:
 672 06d8 4020A0E3 	.LFB7:
 673 06dc 002083E5 		.loc 1 290 0
 270:i2c.c         **** }
 674              	nction supports interworking.
 675 06e0 0CD04BE2 		@ args = 0, pretend = 0, frame = 4
 676 06e4 00689DE8 		@ frame_needed = 1, uses_anonymous_args = 0
 677 06e8 1EFF2FE1 		mov	ip, sp
 678              	.LCFI18:
 679              		stmfd	sp!, {fp, ip, lr, pc}
 680              	.LCFI19:
 681              		sub	fp, ip, #4
 682              	.LCFI20:
 683              		sub	sp, sp, #4
 684              	.LCFI21:
 271:i2c.c         **** 
 272:i2c.c         **** /*****************************************************************************
 273:i2c.c         **** ** Function name:		I2CEngine
 274:i2c.c         **** **
 275:i2c.c         **** ** Descriptions:		The routine to complete a I2C transaction
 276:i2c.c         **** **				from start to stop. All the intermitten
 277:i2c.c         **** **				steps are handled in the interrupt handler.
 278:i2c.c         **** **				Before this routine is called, the read
 279:i2c.c         **** **				length, write length, I2C master buffer,
 280:i2c.c         **** **				and I2C command fields need to be filled.
 281:i2c.c         **** **				see i2cmst.c for more details. 
 282:i2c.c         **** **
 283:i2c.c         **** ** parameters:			None
 284:i2c.c         **** ** Returned value:		true or false, return false only if the
 285:i2c.c         **** **				start condition can never be generated and
 286:i2c.c         **** **				timed out. 
 287:i2c.c         **** ** 
 288:i2c.c         **** *****************************************************************************/
 289:i2c.c         **** unsigned int I2CEngine( void ) 
 290:i2c.c         **** {
 685              	 0
 686              		ldr	r2, .L59
 687              		mov	r3, #0
 688              		str	r3, [r2, #0]
 689 06ec 0DC0A0E1 		.loc 1 292 0
 690              		ldr	r2, .L59+4
 691 06f0 00D82DE9 		mov	r3, #0
 692              		str	r3, [r2, #0]
 693 06f4 04B04CE2 		.loc 1 293 0
 694              		ldr	r2, .L59+8
 695 06f8 04D04DE2 		mov	r3, #0
 696              		str	r3, [r2, #0]
 291:i2c.c         ****     I2CMasterState = I2C_IDLE;
 697              	0
 698 06fc 6C209FE5 		bl	I2CStart
 699 0700 0030A0E3 		mov	r3, r0
 700 0704 003082E5 		cmp	r3, #1
 292:i2c.c         ****     RdIndex = 0;
 701              		.L53
 702 0708 64209FE5 		.loc 1 296 0
 703 070c 0030A0E3 		bl	I2CStop
 704 0710 003082E5 		.loc 1 297 0
 293:i2c.c         ****     WrIndex = 0;
 705              		r3, #0
 706 0714 5C209FE5 		str	r3, [fp, #-16]
 707 0718 0030A0E3 		b	.L55
 708 071c 003082E5 	.L53:
 294:i2c.c         ****     if ( I2CStart() != TRUE )
 709              	c 1 301 0
 710 0720 FEFFFFEB 		ldr	r3, .L59
 711 0724 0030A0E1 		ldr	r3, [r3, #0]
 712 0728 010053E3 		cmp	r3, #5
 713 072c 0300000A 		bne	.L53
 295:i2c.c         ****     {
 296:i2c.c         **** 		I2CStop();
 714              	 1 303 0
 715 0730 FEFFFFEB 		bl	I2CStop
 297:i2c.c         **** 	return ( FALSE );
 716              	loc 1 307 0
 717 0734 0030A0E3 		mov	r3, #1
 718 0738 10300BE5 		str	r3, [fp, #-16]
 719 073c 060000EA 	.L55:
 720              		.loc 1 306 0
 298:i2c.c         ****     }
 299:i2c.c         ****     while ( 1 )
 300:i2c.c         ****     {
 301:i2c.c         **** 	if ( I2CMasterState == DATA_NACK )
 721              	r3, [fp, #-16]
 722 0740 28309FE5 		.loc 1 308 0
 723 0744 003093E5 		mov	r0, r3
 724 0748 050053E3 		sub	sp, fp, #12
 725 074c FBFFFF1A 		ldmfd	sp, {fp, sp, lr}
 302:i2c.c         **** 	{
 303:i2c.c         **** 	    I2CStop();
 726              	r
 727 0750 FEFFFFEB 	.L60:
 304:i2c.c         **** 	    break;
 305:i2c.c         **** 	}
 306:i2c.c         ****     }    
 307:i2c.c         ****     return ( TRUE );      
 728              	align	2
 729 0754 0130A0E3 	.L59:
 730 0758 10300BE5 		.word	I2CMasterState
 731              		.word	RdIndex
 732              		.word	WrIndex
 733 075c 10301BE5 	.LFE7:
 308:i2c.c         **** }
 734              		I2CEngine, .-I2CEngine
 735 0760 0300A0E1 		.align	2
 736 0764 0CD04BE2 		.global	I2C0WaitForSI
 738 076c 1EFF2FE1 	I2C0WaitForSI:
 739              	.LFB8:
 740              		.loc 1 316 0
 741              		@ Function supports interworking.
 742 0770 00000000 		@ args = 0, pretend = 0, frame = 8
 743 0774 00000000 		@ frame_needed = 1, uses_anonymous_args = 0
 744 0778 00000000 		mov	ip, sp
 745              	.LCFI22:
 746              		stmfd	sp!, {fp, ip, lr, pc}
 747              	.LCFI23:
 748              		sub	fp, ip, #4
 749              	.LCFI24:
 750              		sub	sp, sp, #8
 751              	.LCFI25:
 309:i2c.c         **** 
 310:i2c.c         **** /******************************************************************************
 311:i2c.c         **** **                            End Of File
 312:i2c.c         **** ******************************************************************************/
 313:i2c.c         **** 
 314:i2c.c         **** /* laser with I2C. by Xun */
 315:i2c.c         **** unsigned int I2C0WaitForSI(void) //Wait till I2C0 block sets SI
 316:i2c.c         **** {
 752              		r3, #0
 753              		str	r3, [fp, #-16]
 754              		.loc 1 318 0
 755              		b	.L62
 756 077c 0DC0A0E1 	.L63:
 757              		.loc 1 320 0
 758 0780 00D82DE9 		ldr	r3, [fp, #-16]
 759              		add	r3, r3, #1
 760 0784 04B04CE2 		str	r3, [fp, #-16]
 761              		.loc 1 321 0
 762 0788 08D04DE2 		ldr	r2, [fp, #-16]
 763              		mov	r3, #9984
 317:i2c.c         **** 	int timeout = 0;
 764              	 #16
 765 078c 0030A0E3 		cmp	r2, r3
 766 0790 10300BE5 		ble	.L62
 318:i2c.c         **** 	while ( !(I20CONSET & I2CONSET_SI) ) //Wait till SI bit is set. This is important!
 767              	v	r3, #0
 768 0794 0A0000EA 		str	r3, [fp, #-20]
 769              		b	.L65
 319:i2c.c         **** 	{
 320:i2c.c         **** 		timeout++;
 770              	2:
 771 0798 10301BE5 		.loc 1 318 0
 772 079c 013083E2 		mov	r3, #-536870912
 773 07a0 10300BE5 		add	r3, r3, #114688
 321:i2c.c         **** 		if (timeout > 10000) return 0; //In case we have some error on bus
 774              		r3, [r3, #0]
 775 07a4 10201BE5 		and	r3, r3, #8
 776 07a8 273CA0E3 		cmp	r3, #0
 777 07ac 103083E2 		beq	.L63
 778 07b0 030052E1 		.loc 1 323 0
 779 07b4 020000DA 		mov	r3, #1
 780 07b8 0030A0E3 		str	r3, [fp, #-20]
 781 07bc 14300BE5 	.L65:
 782 07c0 070000EA 		ldr	r3, [fp, #-20]
 783              		.loc 1 324 0
 784              		mov	r0, r3
 785 07c4 0E32A0E3 		sub	sp, fp, #12
 786 07c8 073983E2 		ldmfd	sp, {fp, sp, lr}
 787 07cc 003093E5 		bx	lr
 788 07d0 083003E2 	.LFE8:
 790 07d8 EEFFFF0A 		.align	2
 322:i2c.c         **** 	}
 323:i2c.c         **** 	return 1; //SI has been set
 791              	Start
 793 07e0 14300BE5 	I2C0SendStart:
 794              	.LFB9:
 795 07e4 14301BE5 		.loc 1 326 0
 324:i2c.c         **** }
 796              	nction supports interworking.
 797 07e8 0300A0E1 		@ args = 0, pretend = 0, frame = 4
 798 07ec 0CD04BE2 		@ frame_needed = 1, uses_anonymous_args = 0
 799 07f0 00689DE8 		mov	ip, sp
 800 07f4 1EFF2FE1 	.LCFI26:
 801              		stmfd	sp!, {fp, ip, lr, pc}
 802              	.LCFI27:
 803              		sub	fp, ip, #4
 804              	.LCFI28:
 805              		sub	sp, sp, #4
 806              	.LCFI29:
 807              		.loc 1 327 0
 325:i2c.c         **** void I2C0SendStart(void)
 326:i2c.c         **** {
 808              		str	r3, [fp, #-16]
 809              		.loc 1 328 0
 810              		mov	r3, #-536870912
 811              		add	r3, r3, #114688
 812 07f8 0DC0A0E1 		add	r3, r3, #24
 813              		mov	r2, #44
 814 07fc 00D82DE9 		str	r2, [r3, #0]
 815              		.loc 1 329 0
 816 0800 04B04CE2 		mov	r3, #-536870912
 817              		add	r3, r3, #114688
 818 0804 04D04DE2 		mov	r2, #32
 819              		str	r2, [r3, #0]
 327:i2c.c         **** 	unsigned int SI_flag = 0;
 820              	0
 821 0808 0030A0E3 		bl	I2C0WaitForSI
 822 080c 10300BE5 		mov	r3, r0
 328:i2c.c         **** 	I20CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC; //Clear everything
 823              	r	r3, [fp, #-16]
 824 0810 0E32A0E3 		.loc 1 331 0
 825 0814 073983E2 		sub	sp, fp, #12
 826 0818 183083E2 		ldmfd	sp, {fp, sp, lr}
 827 081c 2C20A0E3 		bx	lr
 828 0820 002083E5 	.LFE9:
 329:i2c.c         **** 	I20CONSET = I2CONSET_STA;	/* Set Start flag */
 829              		I2C0SendStart, .-I2C0SendStart
 830 0824 0E32A0E3 		.section	.rodata
 831 0828 073983E2 		.align	2
 832 082c 2020A0E3 	.LC0:
 833 0830 002083E5 		.ascii	"STOP timeout!\000"
 330:i2c.c         **** 	SI_flag = I2C0WaitForSI(); //Wait till the SI bit is set
 834              	t
 835 0834 FEFFFFEB 		.align	2
 836 0838 0030A0E1 		.global	I2C0SendStop
 331:i2c.c         **** }
 838              	SendStop:
 839 0840 0CD04BE2 	.LFB10:
 840 0844 00689DE8 		.loc 1 333 0
 841 0848 1EFF2FE1 		@ Function supports interworking.
 842              		@ args = 0, pretend = 0, frame = 4
 843              		@ frame_needed = 1, uses_anonymous_args = 0
 844              		mov	ip, sp
 845              	.LCFI30:
 846              		stmfd	sp!, {fp, ip, lr, pc}
 847 0000 53544F50 	.LCFI31:
 847      2074696D 
 847      656F7574 
 847      2100
 848              		sub	fp, ip, #4
 849              	.LCFI32:
 850              		sub	sp, sp, #4
 851              	.LCFI33:
 852              		.loc 1 334 0
 853              		mov	r3, #0
 332:i2c.c         **** void I2C0SendStop(void)
 333:i2c.c         **** {
 854              	16]
 855              		.loc 1 335 0
 856              		mov	r3, #-536870912
 857              		add	r3, r3, #114688
 858 084c 0DC0A0E1 		mov	r2, #16
 859              		str	r2, [r3, #0]
 860 0850 00D82DE9 		.loc 1 336 0
 861              		mov	r3, #-536870912
 862 0854 04B04CE2 		add	r3, r3, #114688
 863              		add	r3, r3, #24
 864 0858 04D04DE2 		mov	r2, #8
 865              		str	r2, [r3, #0]
 334:i2c.c         **** 	int timeout = 0;
 866              	0
 867 085c 0030A0E3 		b	.L71
 868 0860 10300BE5 	.L72:
 335:i2c.c         **** 	I20CONSET = I2CONSET_STO; //Set stop bit to send a stop condition
 869              	oc 1 339 0
 870 0864 0E32A0E3 		ldr	r3, [fp, #-16]
 871 0868 073983E2 		add	r3, r3, #1
 872 086c 1020A0E3 		str	r3, [fp, #-16]
 873 0870 002083E5 		.loc 1 340 0
 336:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;  /* Clear SI flag */
 874              	r2, [fp, #-16]
 875 0874 0E32A0E3 		mov	r3, #9984
 876 0878 073983E2 		add	r3, r3, #16
 877 087c 183083E2 		cmp	r2, r3
 878 0880 0820A0E3 		ble	.L71
 879 0884 002083E5 		.loc 1 342 0
 337:i2c.c         **** 	while (I20CONSET & I2CONSET_STO) //Wait till STOP is send. This is important!
 880              	0, .L77
 881 0888 0A0000EA 		bl	puts
 882              		.loc 1 343 0
 338:i2c.c         **** 	{
 339:i2c.c         **** 		timeout++;
 883              	.L76
 884 088c 10301BE5 	.L71:
 885 0890 013083E2 		.loc 1 337 0
 886 0894 10300BE5 		mov	r3, #-536870912
 340:i2c.c         **** 		if (timeout > 10000) //In case we have some error on bus
 887              		r3, r3, #114688
 888 0898 10201BE5 		ldr	r3, [r3, #0]
 889 089c 273CA0E3 		and	r3, r3, #16
 890 08a0 103083E2 		cmp	r3, #0
 891 08a4 030052E1 		bne	.L72
 892 08a8 020000DA 		.loc 1 346 0
 341:i2c.c         **** 		{
 342:i2c.c         **** 			printf("STOP timeout!\n");
 893              	3, #-536870912
 894 08ac 3C009FE5 		add	r3, r3, #114688
 895 08b0 FEFFFFEB 		add	r3, r3, #24
 343:i2c.c         **** 			return;
 896              	v	r2, #8
 897 08b4 0A0000EA 		str	r2, [r3, #0]
 898              	.L76:
 899              		.loc 1 347 0
 900 08b8 0E32A0E3 		sub	sp, fp, #12
 901 08bc 073983E2 		ldmfd	sp, {fp, sp, lr}
 902 08c0 003093E5 		bx	lr
 903 08c4 103003E2 	.L78:
 904 08c8 000053E3 		.align	2
 905 08cc EEFFFF1A 	.L77:
 344:i2c.c         **** 		}
 345:i2c.c         **** 	}
 346:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC;
 906              	0
 907 08d0 0E32A0E3 	.LFE10:
 909 08d8 183083E2 		.align	2
 910 08dc 0820A0E3 		.global	I2C0TX_Byte
 912              	I2C0TX_Byte:
 347:i2c.c         **** }
 913              	
 914 08e4 0CD04BE2 		.loc 1 349 0
 915 08e8 00689DE8 		@ Function supports interworking.
 916 08ec 1EFF2FE1 		@ args = 0, pretend = 0, frame = 4
 917              		@ frame_needed = 1, uses_anonymous_args = 0
 918              		mov	ip, sp
 919              	.LCFI34:
 920 08f0 00000000 		stmfd	sp!, {fp, ip, lr, pc}
 921              	.LCFI35:
 922              		sub	fp, ip, #4
 923              	.LCFI36:
 924              		sub	sp, sp, #4
 925              	.LCFI37:
 926              		mov	r3, r0
 927              		strb	r3, [fp, #-16]
 348:i2c.c         **** void I2C0TX_Byte(unsigned char data)
 349:i2c.c         **** {
 928              		mov	r3, #-536870904
 929              		add	r3, r3, #114688
 930              		ldrb	r2, [fp, #-16]	@ zero_extendqisi2
 931              		str	r2, [r3, #0]
 932 08f4 0DC0A0E1 		.loc 1 351 0
 933              		mov	r3, #-536870912
 934 08f8 00D82DE9 		add	r3, r3, #114688
 935              		add	r3, r3, #24
 936 08fc 04B04CE2 		mov	r2, #40
 937              		str	r2, [r3, #0]
 938 0900 04D04DE2 		.loc 1 352 0
 939              		mov	r2, #-536870912
 940 0904 0030A0E1 		add	r2, r2, #114688
 941 0908 10304BE5 		mov	r3, #-536870912
 350:i2c.c         **** 	I20DAT = data;
 942              	114688
 943 090c 8E32A0E3 		ldr	r3, [r3, #0]
 944 0910 073983E2 		bic	r3, r3, #16
 945 0914 10205BE5 		str	r3, [r2, #0]
 946 0918 002083E5 		.loc 1 353 0
 351:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC | I2CONCLR_STAC; //Clear These to TX data
 947              	2C0WaitForSI
 948 091c 0E32A0E3 		.loc 1 354 0
 949 0920 073983E2 		sub	sp, fp, #12
 950 0924 183083E2 		ldmfd	sp, {fp, sp, lr}
 951 0928 2820A0E3 		bx	lr
 952 092c 002083E5 	.LFE11:
 352:i2c.c         **** 	I20CONSET &= (~I2CONSET_STO);
 953              		I2C0TX_Byte, .-I2C0TX_Byte
 954 0930 0E22A0E3 		.align	2
 955 0934 072982E2 		.global	I2C0RX_Byte
 957 093c 073983E2 	I2C0RX_Byte:
 958 0940 003093E5 	.LFB12:
 959 0944 1030C3E3 		.loc 1 356 0
 960 0948 003082E5 		@ Function supports interworking.
 353:i2c.c         **** 	I2C0WaitForSI(); //wait till TX is finished
 961              	= 0, pretend = 0, frame = 0
 962 094c FEFFFFEB 		@ frame_needed = 1, uses_anonymous_args = 0
 354:i2c.c         **** }
 963              	ov	ip, sp
 964 0950 0CD04BE2 	.LCFI38:
 965 0954 00689DE8 		stmfd	sp!, {fp, ip, lr, pc}
 966 0958 1EFF2FE1 	.LCFI39:
 967              		sub	fp, ip, #4
 968              	.LCFI40:
 969              		.loc 1 357 0
 970              		mov	r3, #-536870912
 971              		add	r3, r3, #114688
 972              		add	r3, r3, #24
 973              		mov	r2, #4
 355:i2c.c         **** unsigned char I2C0RX_Byte(void)
 356:i2c.c         **** {
 974              	3, #0]
 975              		.loc 1 358 0
 976              		mov	r3, #-536870912
 977              		add	r3, r3, #114688
 978 095c 0DC0A0E1 		add	r3, r3, #24
 979              		mov	r2, #8
 980 0960 00D82DE9 		str	r2, [r3, #0]
 981              		.loc 1 359 0
 982 0964 04B04CE2 		bl	I2C0WaitForSI
 983              		.loc 1 360 0
 357:i2c.c         **** 	I20CONCLR = I2CONCLR_AAC; //Send NACK to stop; I2C block will send a STOP automatically, so no nee
 984              	-536870904
 985 0968 0E32A0E3 		add	r3, r3, #114688
 986 096c 073983E2 		ldr	r3, [r3, #0]
 987 0970 183083E2 		and	r3, r3, #255
 988 0974 0420A0E3 		.loc 1 361 0
 989 0978 002083E5 		mov	r0, r3
 358:i2c.c         **** 	I20CONCLR = I2CONCLR_SIC; //Clear SI to Start RX
 990              	p, fp, #12
 991 097c 0E32A0E3 		ldmfd	sp, {fp, sp, lr}
 992 0980 073983E2 		bx	lr
 993 0984 183083E2 	.LFE12:
 995 098c 002083E5 		.section	.rodata
 359:i2c.c         **** 	I2C0WaitForSI(); //wait till RX is finished
 996              	n	2
 997 0990 FEFFFFEB 	.LC1:
 360:i2c.c         **** 	return I20DAT;
 998              	ascii	"Failed for status code: %i(decimal), got status cod"
 999 0994 8E32A0E3 		.ascii	"e: %i(decimal)\012\000"
 1000 0998 073983E2 		.text
 1001 099c 003093E5 		.align	2
 1002 09a0 FF3003E2 		.global	I2C0WriteByte
 361:i2c.c         **** }
 1003              	e	I2C0WriteByte, %function
 1004 09a4 0300A0E1 	I2C0WriteByte:
 1005 09a8 0CD04BE2 	.LFB13:
 1006 09ac 00689DE8 		.loc 1 369 0
 1007 09b0 1EFF2FE1 		@ Function supports interworking.
 1008              		@ args = 0, pretend = 0, frame = 12
 1009              		@ frame_needed = 1, uses_anonymous_args = 0
 1010              		mov	ip, sp
 1011 000e 0000     	.LCFI41:
 1012              		stmfd	sp!, {fp, ip, lr, pc}
 1013 0010 4661696C 	.LCFI42:
 1013      65642066 
 1013      6F722073 
 1013      74617475 
 1013      7320636F 
 1014 0043 653A2025 		sub	fp, ip, #4
 1014      69286465 
 1014      63696D61 
 1014      6C290A00 
 1015              	.LCFI43:
 1016              		sub	sp, sp, #12
 1017              	.LCFI44:
 1018              		str	r0, [fp, #-16]
 1019              		mov	r3, r1
 1020              		strb	r3, [fp, #-20]
 362:i2c.c         **** #define checkStatus(statusCode) \
 363:i2c.c         **** if(I20STAT!=statusCode) \
 364:i2c.c         **** { \
 365:i2c.c         **** 	printf("Failed for status code: %i(decimal), got status code: %i(decimal)\n",statusCode,I20STAT); 
 366:i2c.c         **** 	I2C0SendStop(); return 0; \
 367:i2c.c         **** }
 368:i2c.c         **** unsigned int I2C0WriteByte(unsigned int registerAddress, unsigned char data)
 369:i2c.c         **** {
 1021              	I2C0SendStart
 1022              		.loc 1 371 0
 1023              		mov	r3, #-536870908
 1024              		add	r3, r3, #114688
 1025 09b4 0DC0A0E1 		ldr	r3, [r3, #0]
 1026              		cmp	r3, #8
 1027 09b8 00D82DE9 		beq	.L84
 1028              		mov	r3, #-536870908
 1029 09bc 04B04CE2 		add	r3, r3, #114688
 1030              		ldr	r3, [r3, #0]
 1031 09c0 0CD04DE2 		ldr	r0, .L94
 1032              		mov	r1, #8
 1033 09c4 10000BE5 		mov	r2, r3
 1034 09c8 0130A0E1 		bl	printf
 1035 09cc 14304BE5 		bl	I2C0SendStop
 370:i2c.c         **** 		I2C0SendStart(); //Send START on the Bus to Enter Master Mode
 1036              	r	r3, [fp, #-24]
 1037 09d0 FEFFFFEB 		b	.L86
 371:i2c.c         **** 		checkStatus(0x08); //START sent
 1038              	84:
 1039 09d4 4E32A0E3 		.loc 1 373 0
 1040 09d8 073983E2 		mov	r0, #196
 1041 09dc 003093E5 		bl	I2C0TX_Byte
 1042 09e0 080053E3 		.loc 1 374 0
 1043 09e4 0A00000A 		mov	r3, #-536870908
 1044 09e8 4E32A0E3 		add	r3, r3, #114688
 1045 09ec 073983E2 		ldr	r3, [r3, #0]
 1046 09f0 003093E5 		cmp	r3, #24
 1047 09f4 1C019FE5 		beq	.L87
 1048 09f8 0810A0E3 		mov	r3, #-536870908
 1049 09fc 0320A0E1 		add	r3, r3, #114688
 1050 0a00 FEFFFFEB 		ldr	r3, [r3, #0]
 1051 0a04 FEFFFFEB 		ldr	r0, .L94
 1052 0a08 0030A0E3 		mov	r1, #24
 1053 0a0c 18300BE5 		mov	r2, r3
 1054 0a10 3B0000EA 		bl	printf
 1055              		bl	I2C0SendStop
 372:i2c.c         **** 
 373:i2c.c         **** 		I2C0TX_Byte((0x62<<1) & 0xFE); //Send SlaveAddress + 0 to indicate a write.
 1056              	3, [fp, #-24]
 1057 0a14 C400A0E3 		b	.L86
 1058 0a18 FEFFFFEB 	.L87:
 374:i2c.c         **** 		checkStatus(0x18);//SLA+W sent and ack recevied
 1059              	oc 1 376 0
 1060 0a1c 4E32A0E3 		ldr	r3, [fp, #-16]
 1061 0a20 073983E2 		and	r3, r3, #255
 1062 0a24 003093E5 		mov	r0, r3
 1063 0a28 180053E3 		bl	I2C0TX_Byte
 1064 0a2c 0A00000A 		.loc 1 377 0
 1065 0a30 4E32A0E3 		mov	r3, #-536870908
 1066 0a34 073983E2 		add	r3, r3, #114688
 1067 0a38 003093E5 		ldr	r3, [r3, #0]
 1068 0a3c D4009FE5 		cmp	r3, #40
 1069 0a40 1810A0E3 		beq	.L89
 1070 0a44 0320A0E1 		mov	r3, #-536870908
 1071 0a48 FEFFFFEB 		add	r3, r3, #114688
 1072 0a4c FEFFFFEB 		ldr	r3, [r3, #0]
 1073 0a50 0030A0E3 		ldr	r0, .L94
 1074 0a54 18300BE5 		mov	r1, #40
 1075 0a58 290000EA 		mov	r2, r3
 1076              		bl	printf
 375:i2c.c         **** 
 376:i2c.c         **** 		I2C0TX_Byte(registerAddress); //send the registerAddress
 1077              	mov	r3, #0
 1078 0a5c 10301BE5 		str	r3, [fp, #-24]
 1079 0a60 FF3003E2 		b	.L86
 1080 0a64 0300A0E1 	.L89:
 1081 0a68 FEFFFFEB 		.loc 1 379 0
 377:i2c.c         **** 		checkStatus(0x28); //byte has been sent and ACK recevied
 1082              		r3, [fp, #-20]	@ zero_extendqisi2
 1083 0a6c 4E32A0E3 		mov	r0, r3
 1084 0a70 073983E2 		bl	I2C0TX_Byte
 1085 0a74 003093E5 		.loc 1 380 0
 1086 0a78 280053E3 		mov	r3, #-536870908
 1087 0a7c 0A00000A 		add	r3, r3, #114688
 1088 0a80 4E32A0E3 		ldr	r3, [r3, #0]
 1089 0a84 073983E2 		cmp	r3, #40
 1090 0a88 003093E5 		beq	.L91
 1091 0a8c 84009FE5 		mov	r3, #-536870908
 1092 0a90 2810A0E3 		add	r3, r3, #114688
 1093 0a94 0320A0E1 		ldr	r3, [r3, #0]
 1094 0a98 FEFFFFEB 		ldr	r0, .L94
 1095 0a9c FEFFFFEB 		mov	r1, #40
 1096 0aa0 0030A0E3 		mov	r2, r3
 1097 0aa4 18300BE5 		bl	printf
 1098 0aa8 150000EA 		bl	I2C0SendStop
 1099              		mov	r3, #0
 378:i2c.c         **** 
 379:i2c.c         **** 		I2C0TX_Byte(data); //Finally send the data byte.
 1100              	]
 1101 0aac 14305BE5 		b	.L86
 1102 0ab0 0300A0E1 	.L91:
 1103 0ab4 FEFFFFEB 		.loc 1 382 0
 380:i2c.c         **** 		checkStatus(0x28); //Data Byte has been sent and ACK recevied
 1104              	I2C0SendStop
 1105 0ab8 4E32A0E3 		.loc 1 383 0
 1106 0abc 073983E2 		mov	r3, #1
 1107 0ac0 003093E5 		str	r3, [fp, #-24]
 1108 0ac4 280053E3 	.L86:
 1109 0ac8 0A00000A 		ldr	r3, [fp, #-24]
 1110 0acc 4E32A0E3 		.loc 1 384 0
 1111 0ad0 073983E2 		mov	r0, r3
 1112 0ad4 003093E5 		sub	sp, fp, #12
 1113 0ad8 38009FE5 		ldmfd	sp, {fp, sp, lr}
 1114 0adc 2810A0E3 		bx	lr
 1115 0ae0 0320A0E1 	.L95:
 1116 0ae4 FEFFFFEB 		.align	2
 1117 0ae8 FEFFFFEB 	.L94:
 1118 0aec 0030A0E3 		.word	.LC1
 1119 0af0 18300BE5 	.LFE13:
 1121              		.section	.rodata
 381:i2c.c         **** 
 382:i2c.c         **** 		I2C0SendStop(); //Send STOP since we are done.
 1122              	ascii	"Data='%c' \000"
 1123 0af8 FEFFFFEB 		.text
 383:i2c.c         **** 		return 1;
 1124              	align	2
 1125 0afc 0130A0E3 		.global	I2C0ReadByte
 1127              	I2C0ReadByte:
 1128 0b04 18301BE5 	.LFB14:
 384:i2c.c         **** }
 1129              	 1 386 0
 1130 0b08 0300A0E1 		@ Function supports interworking.
 1131 0b0c 0CD04BE2 		@ args = 0, pretend = 0, frame = 16
 1132 0b10 00689DE8 		@ frame_needed = 1, uses_anonymous_args = 0
 1133 0b14 1EFF2FE1 		mov	ip, sp
 1134              	.LCFI45:
 1135              		stmfd	sp!, {fp, ip, lr, pc}
 1136              	.LCFI46:
 1137 0b18 10000000 		sub	fp, ip, #4
 1138              	.LCFI47:
 1139              		sub	sp, sp, #16
 1140              	.LCFI48:
 1141 0053 00       		str	r0, [fp, #-20]
 1142              		str	r1, [fp, #-24]
 1143 0054 44617461 		.loc 1 387 0
 1143      3D272563 
 1143      272000
 1144 005f 00       		mov	r3, #0
 1145              		str	r3, [fp, #-16]
 1146              		.loc 1 388 0
 1147              		bl	I2C0SendStart
 1148              		.loc 1 389 0
 1149              		mov	r3, #-536870908
 385:i2c.c         **** unsigned int I2C0ReadByte(unsigned int registerAddress, unsigned char *data)
 386:i2c.c         **** {
 1150              		ldr	r2, [r3, #0]
 1151              		ldr	r3, .L109
 1152              		str	r2, [r3, #0]
 1153              		.loc 1 390 0
 1154 0b1c 0DC0A0E1 		mov	r3, #-536870908
 1155              		add	r3, r3, #114688
 1156 0b20 00D82DE9 		ldr	r3, [r3, #0]
 1157              		cmp	r3, #8
 1158 0b24 04B04CE2 		beq	.L97
 1159              		mov	r3, #-536870908
 1160 0b28 10D04DE2 		add	r3, r3, #114688
 1161              		ldr	r3, [r3, #0]
 1162 0b2c 14000BE5 		ldr	r0, .L109+4
 1163 0b30 18100BE5 		mov	r1, #8
 387:i2c.c         **** 	unsigned int RXData = 0;
 1164              	l	printf
 1165 0b34 0030A0E3 		bl	I2C0SendStop
 1166 0b38 10300BE5 		mov	r3, #0
 388:i2c.c         **** 		I2C0SendStart(); //Send START on the Bus to Enter Master Mode
 1167              	r	r3, [fp, #-28]
 1168 0b3c FEFFFFEB 		b	.L99
 389:i2c.c         **** 		I2CSTAT = I20STAT;
 1169              	97:
 1170 0b40 4E32A0E3 		.loc 1 392 0
 1171 0b44 073983E2 		mov	r0, #196
 1172 0b48 002093E5 		bl	I2C0TX_Byte
 1173 0b4c 00329FE5 		.loc 1 393 0
 1174 0b50 002083E5 		mov	r3, #-536870908
 390:i2c.c         **** 		checkStatus(0x08); //START sent
 1175              	3, r3, #114688
 1176 0b54 4E32A0E3 		ldr	r2, [r3, #0]
 1177 0b58 073983E2 		ldr	r3, .L109
 1178 0b5c 003093E5 		str	r2, [r3, #0]
 1179 0b60 080053E3 		.loc 1 394 0
 1180 0b64 0A00000A 		mov	r3, #-536870908
 1181 0b68 4E32A0E3 		add	r3, r3, #114688
 1182 0b6c 073983E2 		ldr	r3, [r3, #0]
 1183 0b70 003093E5 		cmp	r3, #24
 1184 0b74 DC019FE5 		beq	.L100
 1185 0b78 0810A0E3 		mov	r3, #-536870908
 1186 0b7c 0320A0E1 		add	r3, r3, #114688
 1187 0b80 FEFFFFEB 		ldr	r3, [r3, #0]
 1188 0b84 FEFFFFEB 		ldr	r0, .L109+4
 1189 0b88 0030A0E3 		mov	r1, #24
 1190 0b8c 1C300BE5 		mov	r2, r3
 1191 0b90 6A0000EA 		bl	printf
 1192              		bl	I2C0SendStop
 391:i2c.c         **** 
 392:i2c.c         **** 		I2C0TX_Byte((0x62<<1) & 0xFE); //Send SlaveAddress + 0 to indicate a write.
 1193              	3, [fp, #-28]
 1194 0b94 C400A0E3 		b	.L99
 1195 0b98 FEFFFFEB 	.L100:
 393:i2c.c         **** 		I2CSTAT = I20STAT;
 1196              	oc 1 396 0
 1197 0b9c 4E32A0E3 		ldr	r3, [fp, #-20]
 1198 0ba0 073983E2 		and	r3, r3, #255
 1199 0ba4 002093E5 		mov	r0, r3
 1200 0ba8 A4319FE5 		bl	I2C0TX_Byte
 1201 0bac 002083E5 		.loc 1 397 0
 394:i2c.c         **** 		checkStatus(0x18);//SLA+W sent and ack recevied
 1202              	3, #-536870908
 1203 0bb0 4E32A0E3 		add	r3, r3, #114688
 1204 0bb4 073983E2 		ldr	r2, [r3, #0]
 1205 0bb8 003093E5 		ldr	r3, .L109
 1206 0bbc 180053E3 		str	r2, [r3, #0]
 1207 0bc0 0A00000A 		.loc 1 398 0
 1208 0bc4 4E32A0E3 		mov	r3, #-536870908
 1209 0bc8 073983E2 		add	r3, r3, #114688
 1210 0bcc 003093E5 		ldr	r3, [r3, #0]
 1211 0bd0 80019FE5 		cmp	r3, #40
 1212 0bd4 1810A0E3 		beq	.L102
 1213 0bd8 0320A0E1 		mov	r3, #-536870908
 1214 0bdc FEFFFFEB 		add	r3, r3, #114688
 1215 0be0 FEFFFFEB 		ldr	r3, [r3, #0]
 1216 0be4 0030A0E3 		ldr	r0, .L109+4
 1217 0be8 1C300BE5 		mov	r1, #40
 1218 0bec 530000EA 		mov	r2, r3
 1219              		bl	printf
 395:i2c.c         **** 
 396:i2c.c         **** 		I2C0TX_Byte(registerAddress);
 1220              	mov	r3, #0
 1221 0bf0 14301BE5 		str	r3, [fp, #-28]
 1222 0bf4 FF3003E2 		b	.L99
 1223 0bf8 0300A0E1 	.L102:
 1224 0bfc FEFFFFEB 		.loc 1 400 0
 397:i2c.c         **** 		I2CSTAT = I20STAT;
 1225              	2C0SendStop
 1226 0c00 4E32A0E3 		.loc 1 402 0
 1227 0c04 073983E2 		bl	I2C0SendStart
 1228 0c08 002093E5 		.loc 1 403 0
 1229 0c0c 40319FE5 		mov	r3, #-536870908
 1230 0c10 002083E5 		add	r3, r3, #114688
 398:i2c.c         **** 		checkStatus(0x28);
 1231              	2, [r3, #0]
 1232 0c14 4E32A0E3 		ldr	r3, .L109
 1233 0c18 073983E2 		str	r2, [r3, #0]
 1234 0c1c 003093E5 		.loc 1 404 0
 1235 0c20 280053E3 		mov	r3, #-536870908
 1236 0c24 0A00000A 		add	r3, r3, #114688
 1237 0c28 4E32A0E3 		ldr	r3, [r3, #0]
 1238 0c2c 073983E2 		cmp	r3, #8
 1239 0c30 003093E5 		beq	.L104
 1240 0c34 1C019FE5 		mov	r3, #-536870908
 1241 0c38 2810A0E3 		add	r3, r3, #114688
 1242 0c3c 0320A0E1 		ldr	r3, [r3, #0]
 1243 0c40 FEFFFFEB 		ldr	r0, .L109+4
 1244 0c44 FEFFFFEB 		mov	r1, #8
 1245 0c48 0030A0E3 		mov	r2, r3
 1246 0c4c 1C300BE5 		bl	printf
 1247 0c50 3A0000EA 		bl	I2C0SendStop
 1248              		mov	r3, #0
 399:i2c.c         **** 
 400:i2c.c         **** 		I2C0SendStop();
 1249              	]
 1250 0c54 FEFFFFEB 		b	.L99
 401:i2c.c         **** 
 402:i2c.c         **** 		I2C0SendStart(); //Send START on the Bus to Enter Master Mode
 1251              	104:
 1252 0c58 FEFFFFEB 		.loc 1 406 0
 403:i2c.c         **** 		I2CSTAT = I20STAT;
 1253              	ov	r0, #197
 1254 0c5c 4E32A0E3 		bl	I2C0TX_Byte
 1255 0c60 073983E2 		.loc 1 407 0
 1256 0c64 002093E5 		mov	r3, #-536870908
 1257 0c68 E4309FE5 		add	r3, r3, #114688
 1258 0c6c 002083E5 		ldr	r2, [r3, #0]
 404:i2c.c         **** 		checkStatus(0x08); //START sent
 1259              	3, .L109
 1260 0c70 4E32A0E3 		str	r2, [r3, #0]
 1261 0c74 073983E2 		.loc 1 408 0
 1262 0c78 003093E5 		mov	r3, #-536870908
 1263 0c7c 080053E3 		add	r3, r3, #114688
 1264 0c80 0A00000A 		ldr	r3, [r3, #0]
 1265 0c84 4E32A0E3 		cmp	r3, #64
 1266 0c88 073983E2 		beq	.L106
 1267 0c8c 003093E5 		mov	r3, #-536870908
 1268 0c90 C0009FE5 		add	r3, r3, #114688
 1269 0c94 0810A0E3 		ldr	r3, [r3, #0]
 1270 0c98 0320A0E1 		ldr	r0, .L109+4
 1271 0c9c FEFFFFEB 		mov	r1, #64
 1272 0ca0 FEFFFFEB 		mov	r2, r3
 1273 0ca4 0030A0E3 		bl	printf
 1274 0ca8 1C300BE5 		bl	I2C0SendStop
 1275 0cac 230000EA 		mov	r3, #0
 1276              		str	r3, [fp, #-28]
 405:i2c.c         **** 
 406:i2c.c         **** 		I2C0TX_Byte((0x62<<1) | 0x01); //This makes SLA-RW bit to 1 which indicates read.
 1277              	oc 1 410 0
 1278 0cb0 C500A0E3 		bl	I2C0RX_Byte
 1279 0cb4 FEFFFFEB 		mov	r3, r0
 407:i2c.c         **** 		I2CSTAT = I20STAT;
 1280              	r	r3, [fp, #-16]
 1281 0cb8 4E32A0E3 		.loc 1 412 0
 1282 0cbc 073983E2 		ldr	r3, [fp, #-16]
 1283 0cc0 002093E5 		and	r3, r3, #255
 1284 0cc4 88309FE5 		ldr	r2, [fp, #-24]
 1285 0cc8 002083E5 		strb	r3, [r2, #0]
 408:i2c.c         **** 		checkStatus(0x40); //SLA-R has been Transmitted and ACK received.
 1286              	1 413 0
 1287 0ccc 4E32A0E3 		ldr	r0, .L109+8
 1288 0cd0 073983E2 		ldr	r1, [fp, #-16]
 1289 0cd4 003093E5 		bl	printf
 1290 0cd8 400053E3 		.loc 1 414 0
 1291 0cdc 0A00000A 		bl	I2C0SendStop
 1292 0ce0 4E32A0E3 		.loc 1 415 0
 1293 0ce4 073983E2 		mov	r3, #1
 1294 0ce8 003093E5 		str	r3, [fp, #-28]
 1295 0cec 64009FE5 	.L99:
 1296 0cf0 4010A0E3 		ldr	r3, [fp, #-28]
 1297 0cf4 0320A0E1 		.loc 1 416 0
 1298 0cf8 FEFFFFEB 		mov	r0, r3
 1299 0cfc FEFFFFEB 		sub	sp, fp, #12
 1300 0d00 0030A0E3 		ldmfd	sp, {fp, sp, lr}
 1301 0d04 1C300BE5 		bx	lr
 1302 0d08 0C0000EA 	.L110:
 1303              		.align	2
 409:i2c.c         **** 
 410:i2c.c         **** 		RXData = I2C0RX_Byte();
 1304              	TAT
 1305 0d0c FEFFFFEB 		.word	.LC1
 1306 0d10 0030A0E1 		.word	.LC2
 1307 0d14 10300BE5 	.LFE14:
 411:i2c.c         **** 
 412:i2c.c         **** 		*data = (unsigned char)RXData; //Write recieved data to buffer
 1308              	ze	I2C0ReadByte, .-I2C0ReadByte
 1309 0d18 10301BE5 		.align	2
 1310 0d1c FF3003E2 		.global	write_byte
 1312 0d24 0030C2E5 	write_byte:
 413:i2c.c         **** 		printf("Data='%c' ",RXData);
 1313              	5:
 1314 0d28 2C009FE5 		.loc 1 420 0
 1315 0d2c 10101BE5 		@ Function supports interworking.
 1316 0d30 FEFFFFEB 		@ args = 0, pretend = 0, frame = 20
 414:i2c.c         **** 		I2C0SendStop();
 1317              	rame_needed = 1, uses_anonymous_args = 0
 1318 0d34 FEFFFFEB 		mov	ip, sp
 415:i2c.c         **** 	return 1;
 1319              	CFI49:
 1320 0d38 0130A0E3 		stmfd	sp!, {fp, ip, lr, pc}
 1321 0d3c 1C300BE5 	.LCFI50:
 1322              		sub	fp, ip, #4
 1323 0d40 1C301BE5 	.LCFI51:
 416:i2c.c         **** }
 1324              	sp, sp, #20
 1325 0d44 0300A0E1 	.LCFI52:
 1326 0d48 0CD04BE2 		mov	r3, r0
 1327 0d4c 00689DE8 		strb	r3, [fp, #-24]
 1328 0d50 1EFF2FE1 		mov	r3, r1
 1329              		strb	r3, [fp, #-28]
 1330              		mov	r3, r2
 1331              		strb	r3, [fp, #-32]
 1332 0d54 00000000 		.loc 1 424 0
 1333 0d58 10000000 		ldr	r2, .L116
 1334 0d5c 54000000 		mov	r3, #0
 1335              		str	r3, [r2, #0]
 1336              		.loc 1 425 0
 1337              		ldr	r2, .L116+4
 1338              		mov	r3, #3
 1339              		str	r3, [r2, #0]
 1340              		.loc 1 426 0
 1341              		ldrb	r3, [fp, #-24]	@ zero_extendqisi2
 417:i2c.c         **** 
 418:i2c.c         **** 
 419:i2c.c         **** /* with irq */
 420:i2c.c         **** void write_byte(unsigned char slave_address, unsigned char register_address, unsigned char data){
 1342              	1
 1343              		and	r3, r3, #255
 1344              		and	r3, r3, #255
 1345              		mov	r2, #254
 1346 0d60 0DC0A0E1 		and	r3, r3, r2
 1347              		ldr	r2, .L116+8
 1348 0d64 00D82DE9 		strb	r3, [r2, #0]
 1349              		.loc 1 427 0
 1350 0d68 04B04CE2 		ldr	r2, .L116+8
 1351              		ldrb	r3, [fp, #-28]
 1352 0d6c 14D04DE2 		strb	r3, [r2, #1]
 1353              		.loc 1 428 0
 1354 0d70 0030A0E1 		ldr	r2, .L116+8
 1355 0d74 18304BE5 		ldrb	r3, [fp, #-32]
 1356 0d78 0130A0E1 		strb	r3, [r2, #2]
 1357 0d7c 1C304BE5 		.loc 1 431 0
 1358 0d80 0230A0E1 		bl	I2CStart
 1359 0d84 20304BE5 		mov	r3, r0
 421:i2c.c         **** 	/* initialize Master Transmitter mode */
 422:i2c.c         **** //	I20CONSET = I2CONSET_I2EN;	// set I2EN bit, clear STA, STO and AA bit
 423:i2c.c         **** 
 424:i2c.c         **** 	WrIndex=0;
 1360              	]
 1361 0d88 7C209FE5 	.L112:
 1362 0d8c 0030A0E3 		.loc 1 435 0
 1363 0d90 003082E5 		ldr	r3, .L116+12
 425:i2c.c         **** 	I2CWriteLength = 3;
 1364              		r3, [r3, #0]
 1365 0d94 74209FE5 		cmp	r3, #5
 1366 0d98 0330A0E3 		bne	.L112
 1367 0d9c 003082E5 	.LBB2:
 426:i2c.c         **** 	I2CMasterBuffer[0] = (slave_address << 1) & 0xFE;	// laser address + write bit(0)
 1368              	c 1 436 0
 1369 0da0 18305BE5 		bl	I2CStop
 1370 0da4 8330A0E1 		mov	r3, r0
 1371 0da8 FF3003E2 		str	r3, [fp, #-16]
 1372 0dac FF3003E2 	.LBE2:
 1373 0db0 FE20A0E3 		.loc 1 440 0
 1374 0db4 023003E0 		sub	sp, fp, #12
 1375 0db8 54209FE5 		ldmfd	sp, {fp, sp, lr}
 1376 0dbc 0030C2E5 		bx	lr
 427:i2c.c         ****     I2CMasterBuffer[1] = register_address;
 1377              	align	2
 1378 0dc0 4C209FE5 	.L116:
 1379 0dc4 1C305BE5 		.word	WrIndex
 1380 0dc8 0130C2E5 		.word	I2CWriteLength
 428:i2c.c         ****     I2CMasterBuffer[2] = data;
 1381              	rd	I2CMasterBuffer
 1382 0dcc 40209FE5 		.word	I2CMasterState
 1383 0dd0 20305BE5 	.LFE15:
 429:i2c.c         **** 
 430:i2c.c         **** 	// enter Master Transmitter mode
 431:i2c.c         ****     unsigned int flag_start = I2CStart();
 1385              	ign	2
 1386 0dd8 FEFFFFEB 		.global	read_byte
 1388 0de0 14300BE5 	read_byte:
 1389              	.LFB16:
 432:i2c.c         **** 
 433:i2c.c         **** 	// Set Stop flag
 434:i2c.c         **** 	while(1){
 435:i2c.c         **** 		if( I2CMasterState == DATA_NACK ){
 1390              	 1 442 0
 1391 0de4 2C309FE5 		@ Function supports interworking.
 1392 0de8 003093E5 		@ args = 0, pretend = 0, frame = 24
 1393 0dec 050053E3 		@ frame_needed = 1, uses_anonymous_args = 0
 1394 0df0 FBFFFF1A 		mov	ip, sp
 1395              	.LCFI53:
 436:i2c.c         **** 			unsigned int flag_stop = I2CStop();
 1396              		sp!, {fp, ip, lr, pc}
 1397 0df4 FEFFFFEB 	.LCFI54:
 1398 0df8 0030A0E1 		sub	fp, ip, #4
 1399 0dfc 10300BE5 	.LCFI55:
 1400              		sub	sp, sp, #24
 437:i2c.c         **** 			break;
 438:i2c.c         **** 		}
 439:i2c.c         **** 	}
 440:i2c.c         **** }
 1401              	56:
 1402 0e00 0CD04BE2 		mov	r3, r0
 1403 0e04 00689DE8 		mov	r2, r1
 1404 0e08 1EFF2FE1 		strb	r3, [fp, #-32]
 1405              		mov	r3, r2
 1406              		strb	r3, [fp, #-36]
 1407              		.loc 1 447 0
 1408 0e0c 00000000 		ldr	r2, .L126
 1409 0e10 00000000 		mov	r3, #0
 1410 0e14 00000000 		str	r3, [r2, #0]
 1411 0e18 00000000 		.loc 1 448 0
 1412              		ldr	r2, .L126+4
 1413              		mov	r3, #2
 1414              		str	r3, [r2, #0]
 1415              		.loc 1 449 0
 1416              		ldrb	r3, [fp, #-32]	@ zero_extendqisi2
 1417              		mov	r3, r3, asl #1
 1418              		and	r3, r3, #255
 441:i2c.c         **** 
 442:i2c.c         **** unsigned char read_byte(unsigned char slave_address, unsigned char register_address){
 1419              		mov	r2, #254
 1420              		and	r3, r3, r2
 1421              		ldr	r2, .L126+8
 1422              		strb	r3, [r2, #0]
 1423 0e1c 0DC0A0E1 		.loc 1 450 0
 1424              		ldr	r2, .L126+8
 1425 0e20 00D82DE9 		ldrb	r3, [fp, #-36]
 1426              		strb	r3, [r2, #1]
 1427 0e24 04B04CE2 		.loc 1 453 0
 1428              		bl	I2CStart
 1429 0e28 18D04DE2 		mov	r3, r0
 1430              		str	r3, [fp, #-28]
 1431 0e2c 0030A0E1 	.L119:
 1432 0e30 0120A0E1 		.loc 1 457 0
 1433 0e34 20304BE5 		ldr	r3, .L126+12
 1434 0e38 0230A0E1 		ldr	r3, [r3, #0]
 1435 0e3c 24304BE5 		cmp	r3, #5
 443:i2c.c         **** 	/* initialize Master Receiver mode */
 444:i2c.c         **** //	I20CONSET = I2CONSET_I2EN;	// set I2EN bit, clear STA, STO and AA bit
 445:i2c.c         **** 
 446:i2c.c         **** 	/* write register address */
 447:i2c.c         **** 	WrIndex=0;
 1436              	
 1437 0e40 E4209FE5 		.loc 1 458 0
 1438 0e44 0030A0E3 		bl	I2CStop
 1439 0e48 003082E5 		mov	r3, r0
 448:i2c.c         **** 	I2CWriteLength = 2;
 1440              	r	r3, [fp, #-20]
 1441 0e4c DC209FE5 	.LBE3:
 1442 0e50 0230A0E3 		.loc 1 464 0
 1443 0e54 003082E5 		ldr	r2, .L126+16
 449:i2c.c         **** 	I2CMasterBuffer[0] = (slave_address << 1) & 0xFE;	// laser address + write bit(0)
 1444              		r3, #0
 1445 0e58 20305BE5 		str	r3, [r2, #0]
 1446 0e5c 8330A0E1 		.loc 1 465 0
 1447 0e60 FF3003E2 		ldr	r2, .L126+20
 1448 0e64 FF3003E2 		mov	r3, #1
 1449 0e68 FE20A0E3 		str	r3, [r2, #0]
 1450 0e6c 023003E0 		.loc 1 466 0
 1451 0e70 BC209FE5 		ldrb	r3, [fp, #-32]	@ zero_extendqisi2
 1452 0e74 0030C2E5 		mov	r3, r3, asl #1
 450:i2c.c         **** 	I2CMasterBuffer[1] = register_address;	// register address
 1453              	r3, #255
 1454 0e78 B4209FE5 		orr	r3, r3, #1
 1455 0e7c 24305BE5 		and	r3, r3, #255
 1456 0e80 0130C2E5 		and	r3, r3, #255
 451:i2c.c         **** 
 452:i2c.c         **** 	// enter Master Receiver mode
 453:i2c.c         ****     unsigned int flag_start = I2CStart();
 1457              		r2, .L126+8
 1458 0e84 FEFFFFEB 		strb	r3, [r2, #0]
 1459 0e88 0030A0E1 		.loc 1 468 0
 1460 0e8c 1C300BE5 		bl	I2CStart
 1461              		mov	r3, r0
 454:i2c.c         **** 
 455:i2c.c         **** 	// Set Stop flag
 456:i2c.c         **** 	while(1){
 457:i2c.c         **** 		if( I2CMasterState == DATA_NACK ){
 1462              	r3, [fp, #-28]
 1463 0e90 A0309FE5 		.loc 1 470 0
 1464 0e94 003093E5 		ldr	r3, .L126+8
 1465 0e98 050053E3 		ldrb	r3, [r3, #3]
 1466 0e9c FBFFFF1A 		strb	r3, [fp, #-21]
 1467              	.L122:
 458:i2c.c         **** 			unsigned int flag_stop = I2CStop();
 1468              	1 474 0
 1469 0ea0 FEFFFFEB 		ldr	r3, .L126+12
 1470 0ea4 0030A0E1 		ldr	r3, [r3, #0]
 1471 0ea8 14300BE5 		cmp	r3, #5
 1472              		bne	.L122
 459:i2c.c         **** 			break;
 460:i2c.c         **** 		}
 461:i2c.c         **** 	}
 462:i2c.c         **** 
 463:i2c.c         **** 	/* read one byte */
 464:i2c.c         **** 	RdIndex=0;
 1473              	:
 1474 0eac 88209FE5 		.loc 1 475 0
 1475 0eb0 0030A0E3 		bl	I2CStop
 1476 0eb4 003082E5 		mov	r3, r0
 465:i2c.c         **** 	I2CReadLength = 1;
 1477              		r3, [fp, #-16]
 1478 0eb8 80209FE5 	.LBE4:
 1479 0ebc 0130A0E3 		.loc 1 480 0
 1480 0ec0 003082E5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 466:i2c.c         ****     I2CMasterBuffer[0] = (slave_address << 1) | 0x01;	// laser address + read bit(1)
 1481              	c 1 481 0
 1482 0ec4 20305BE5 		mov	r0, r3
 1483 0ec8 8330A0E1 		sub	sp, fp, #12
 1484 0ecc FF3003E2 		ldmfd	sp, {fp, sp, lr}
 1485 0ed0 013083E3 		bx	lr
 1486 0ed4 FF3003E2 	.L127:
 1487 0ed8 FF3003E2 		.align	2
 1488 0edc 50209FE5 	.L126:
 1489 0ee0 0030C2E5 		.word	WrIndex
 467:i2c.c         **** 
 468:i2c.c         ****     flag_start = I2CStart();
 1490              	CWriteLength
 1491 0ee4 FEFFFFEB 		.word	I2CMasterBuffer
 1492 0ee8 0030A0E1 		.word	I2CMasterState
 1493 0eec 1C300BE5 		.word	RdIndex
 469:i2c.c         **** 
 470:i2c.c         **** 	unsigned char byte_read = I2CMasterBuffer[3];
 1494              	rd	I2CReadLength
 1495 0ef0 3C309FE5 	.LFE16:
 1497 0ef8 15304BE5 		.comm	I2CCmd,4,4
 1498              		.comm	I2CMode,4,4
 471:i2c.c         **** 
 472:i2c.c         **** 	// Set Stop flag
 473:i2c.c         **** 	while(1){
 474:i2c.c         **** 		if( I2CMasterState == DATA_NACK ){
 1499              	m	I2CMasterBuffer,32,1
 1500 0efc 34309FE5 		.comm	I2CSlaveBuffer,32,1
 1501 0f00 003093E5 		.comm	I2CReadLength,4,4
 1502 0f04 050053E3 		.comm	I2CWriteLength,4,4
 1503 0f08 FBFFFF1A 		.comm	I2CSTAT,4,4
 1504              		.section	.debug_frame,"",%progbits
 475:i2c.c         **** 			unsigned int flag_stop = I2CStop();
 1505              	e0:
 1506 0f0c FEFFFFEB 		.4byte	.LECIE0-.LSCIE0
 1507 0f10 0030A0E1 	.LSCIE0:
 1508 0f14 10300BE5 		.4byte	0xffffffff
 1509              		.byte	0x1
 476:i2c.c         **** 			break;
 477:i2c.c         **** 		}
 478:i2c.c         **** 	}
 479:i2c.c         **** 
 480:i2c.c         **** 	return byte_read;
 1510              	ii	"\000"
 1511 0f18 15305BE5 		.uleb128 0x1
 481:i2c.c         **** }
 1512              	sleb128 -4
 1513 0f1c 0300A0E1 		.byte	0xe
 1514 0f20 0CD04BE2 		.byte	0xc
 1515 0f24 00689DE8 		.uleb128 0xd
 1516 0f28 1EFF2FE1 		.uleb128 0x0
 1517              		.align	2
 1518              	.LECIE0:
 1519              	.LSFDE0:
 1520 0f2c 00000000 		.4byte	.LEFDE0-.LASFDE0
 1521 0f30 00000000 	.LASFDE0:
 1522 0f34 00000000 		.4byte	.Lframe0
 1523 0f38 00000000 		.4byte	.LFB2
 1524 0f3c 00000000 		.4byte	.LFE2-.LFB2
 1525 0f40 00000000 		.byte	0x4
 1526              		.4byte	.LCFI0-.LFB2
 1527              		.byte	0xd
 1528              		.uleb128 0xc
 1529              		.byte	0x4
 1530              		.4byte	.LCFI1-.LCFI0
 1531              		.byte	0x8e
 1532              		.uleb128 0x2
 1533              		.byte	0x8d
 1534              		.uleb128 0x3
 1927              		.byte	0x7b
DEFINED SYMBOLS
                            *ABS*:00000000 i2c.c
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:15     .bss:00000000 I2CMasterState
                             .bss:00000000 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:21     .bss:00000004 I2CSlaveState
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:27     .bss:00000008 I2CCount
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:33     .bss:0000000c RdIndex
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:39     .bss:00000010 WrIndex
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:45     .text:00000000 I2C0MasterHandler
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:52     .text:00000000 $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:73     .text:00000034 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:156    .text:00000178 $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:416    .text:00000480 $d
                            *COM*:00000020 I2CMasterBuffer
                            *COM*:00000004 I2CCmd
                            *COM*:00000004 I2CWriteLength
                            *COM*:00000004 I2CReadLength
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:428    .text:0000049c I2C0_send_motordata
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:434    .text:0000049c $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:683    .text:000006ec I2CEngine
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:489    .text:00000530 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:500    .text:00000548 I2CStart
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:506    .text:00000548 $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:566    .text:000005d8 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:572    .text:000005dc I2CStop
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:578    .text:000005dc $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:615    .text:00000638 I2CInit
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:742    .text:00000770 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:750    .text:0000077c I2C0WaitForSI
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:756    .text:0000077c $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:806    .text:000007f8 I2C0SendStart
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:852    .text:0000084c I2C0SendStop
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:920    .text:000008f0 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:926    .text:000008f4 I2C0TX_Byte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:932    .text:000008f4 $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:972    .text:0000095c I2C0RX_Byte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1019   .text:000009b4 I2C0WriteByte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1137   .text:00000b18 $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1148   .text:00000b1c I2C0ReadByte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1154   .text:00000b1c $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1332   .text:00000d54 $d
                            *COM*:00000004 I2CSTAT
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1340   .text:00000d60 write_byte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1346   .text:00000d60 $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1408   .text:00000e0c $d
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1417   .text:00000e1c read_byte
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1423   .text:00000e1c $a
C:\Users\XY\AppData\Local\Temp/ccKCaaaa.s:1520   .text:00000f2c $d
                            *COM*:00000004 I2CMode
                            *COM*:00000020 I2CSlaveBuffer

UNDEFINED SYMBOLS
puts
printf
